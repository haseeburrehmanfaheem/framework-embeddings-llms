This is path 1 for the API with depth 2:
depth : 0
public boolean setLockCredential(LockscreenCredential p1, LockscreenCredential p2, int p3){
	int v1 = p1.getType();
	boolean v2 = p0.hasPermission("android.permission.ACCESS_KEYGUARD_SECURE_STORAGE");
	boolean v3 = p0.hasPermission("android.permission.SET_AND_VERIFY_LOCKSCREEN_CREDENTIALS");
	boolean v4 = p0.hasPermission("android.permission.SET_INITIAL_LOCK");
	boolean v5 = p2.isNone();
	long v6 = Binder.clearCallingIdentity();
	p0.enforceFrpResolved();
	boolean v8 = p2.isNone();
	boolean v9 = p0.isProfileWithUnifiedLock(p3);
	UserInfo v10 = this.mUserManager.getProfileParent(p3);
	VerifyCredentialResponse v11 = p0.verifyCredential(p2, UserInfo.id, 0);
	p2.zeroize();
	LockscreenCredential v13 = LockscreenCredential.createNone();
	boolean v14 = p0.setLockCredentialInternal(p1, phiInstruction, p3, 0);
	p0.setSeparateProfileChallengeEnabledLocked(p3, 1, 0);
	p0.notifyPasswordChanged(p1, p3);
	boolean v17 = p0.isCredentialSharableWithParent(p3);
	p0.setDeviceUnlockedForUser(p3);
	p0.notifySeparateProfileChallengeChanged(p3);
	p0.onPostPasswordChanged(p1, p3);
	p0.scheduleGc();
	Binder.restoreCallingIdentity(v6);
	return 1;
}
-----
depth : 1
public int getType(){
	p0.ensureNotZeroized();
	return this.mType;
}
-----
depth : 2
public void ensureNotZeroized(){
	Preconditions.checkState(phiInstruction, "Credential is already zeroized");
	return;
}
-----
depth : 1
public void enforceFrpResolved(){
	ContentResolver v1 = this.mContext.getContentResolver();
	int v2 = this.mInjector.settingsSecureGetInt(v1, "user_setup_complete", 0, 0);
	int v3 = this.mInjector.settingsSecureGetInt(v1, "secure_frp_mode", 0, 0);
	return;
}
-----
depth : 2
public int settingsSecureGetInt(ContentResolver p1, String p2, int p3, int p4){
	int v1 = Settings$Secure.getIntForUser(p1, p2, p3, p4);
	return v1;
}
-----
depth : 2
public int settingsSecureGetInt(ContentResolver p1, String p2, int p3, int p4){
	int v1 = Settings$Secure.getIntForUser(p1, p2, p3, p4);
	return v1;
}
-----
depth : 1
public boolean isProfileWithUnifiedLock(int p1){
	boolean v1 = p0.isCredentialSharableWithParent(p1);
	boolean v2 = p0.getSeparateProfileChallengeEnabledInternal(p1);
	return phiInstruction;
}
-----
depth : 2
public boolean isCredentialSharableWithParent(int p1){
	UserManager v1 = p0.getUserManagerFromCache(p1);
	boolean v2 = v1.isCredentialSharableWithParent();
	return v2;
}
-----
depth : 2
public boolean getSeparateProfileChallengeEnabledInternal(int p1){
	boolean v1 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
	return v1;
}
-----
depth : 1
public VerifyCredentialResponse verifyCredential(LockscreenCredential p1, int p2, int p3){
	boolean v1 = p0.hasPermission("android.permission.ACCESS_KEYGUARD_SECURE_STORAGE");
	boolean v2 = p0.hasPermission("android.permission.SET_AND_VERIFY_LOCKSCREEN_CREDENTIALS");
	long v3 = Binder.clearCallingIdentity();
	VerifyCredentialResponse v4 = p0.doVerifyCredential(p1, p2, 0, p3);
	Binder.restoreCallingIdentity(v3);
	p0.scheduleGc();
	return v4;
}
-----
depth : 2
public boolean hasPermission(String p1){
	return phiInstruction;
}
-----
depth : 2
public boolean hasPermission(String p1){
	return phiInstruction;
}
-----
depth : 2
public VerifyCredentialResponse doVerifyCredential(LockscreenCredential p1, int p2, ICheckCredentialProgressCallback p3, int p4){
	boolean v1 = p1.isNone();
	ContentResolver v2 = this.mContext.getContentResolver();
	int v3 = this.mInjector.settingsGlobalGetInt(v2, "device_provisioned", 0);
	VerifyCredentialResponse v4 = p0.spBasedDoVerifyCredential(p1, p2, p3, p4);
	LockSettingsStorage$CredentialHash v5 = this.mStorage.readCredentialHash(p2);
	boolean v6 = p1.checkAgainstStoredType(LockSettingsStorage$CredentialHash.type);
	StringBuilder v6 = new StringBuilder();
	StringBuilder v8 = v6.append("doVerifyCredential type mismatch with stored credential?? stored: ");
	StringBuilder v9 = v6.append(LockSettingsStorage$CredentialHash.type);
	StringBuilder v10 = v6.append(" passed in: ");
	int v11 = p1.getType();
	StringBuilder v12 = v6.append(v11);
	String v13 = v6.toString();
	int v14 = Slog.wtf("LockSettingsService", v13);
	return VerifyCredentialResponse.ERROR;
}
-----
depth : 2
public void scheduleGc(){
	LockSettingsService$$ExternalSyntheticLambda3 v0 = new LockSettingsService$$ExternalSyntheticLambda3();
	boolean v2 = this.mHandler.postDelayed(v0, 2000);
	return;
}
-----
depth : 1
public boolean setLockCredentialInternal(LockscreenCredential p1, LockscreenCredential p2, int p3, boolean p4){
	Object v1 = Objects.requireNonNull(p1);
	Object v2 = Objects.requireNonNull(p2);
	boolean v3 = p0.isSyntheticPasswordBasedCredentialLocked(p3);
	boolean v4 = p1.isNone();
	LockSettingsStorage$CredentialHash v5 = this.mStorage.readCredentialHash(p3);
	boolean v6 = p0.isProfileWithUnifiedLock(p3);
	boolean v7 = p2.isNone();
	LockscreenCredential v8 = p0.getDecryptedPasswordForTiedProfile(p3);
	int v9 = Slog.e("LockSettingsService", "Failed to decrypt child profile key", caughtException);
	SyntheticPasswordManager$AuthenticationToken v10 = p0.initializeSyntheticPasswordLocked(LockSettingsStorage$CredentialHash.hash, phiInstruction, p3);
	boolean v11 = p0.spBasedSetLockCredentialInternalLocked(p1, phiInstruction, p3, p4);
	return v11;
}
-----
depth : 2
public boolean isSyntheticPasswordBasedCredentialLocked(int p1){
	LockSettingsStorage$PersistentData v1 = this.mStorage.readPersistentDataBlock();
	return phiInstruction;
}
-----
depth : 2
public LockSettingsStorage$CredentialHash readCredentialHash(int p1){
	LockSettingsStorage$CredentialHash v1 = p0.readPasswordHashIfExists(p1);
	LockSettingsStorage$CredentialHash v2 = p0.readPatternHashIfExists(p1);
	LockSettingsStorage$CredentialHash v3 = LockSettingsStorage$CredentialHash.createEmptyHash();
	return v3;
}
-----
depth : 2
public boolean isProfileWithUnifiedLock(int p1){
	boolean v1 = p0.isCredentialSharableWithParent(p1);
	boolean v2 = p0.getSeparateProfileChallengeEnabledInternal(p1);
	return phiInstruction;
}
-----
depth : 2
public LockscreenCredential getDecryptedPasswordForTiedProfile(int p1){
	byte[] v1 = this.mStorage.readChildProfileLock(p1);
	byte[] v2 = Arrays.copyOfRange(v1, 0, 12);
	byte[] v3 = Arrays.copyOfRange(v1, 12, v1.length);
	StringBuilder v3 = new StringBuilder();
	StringBuilder v5 = v3.append("profile_key_name_decrypt_");
	StringBuilder v6 = v3.append(p1);
	String v7 = v3.toString();
	Key v8 = this.mJavaKeyStore.getKey(v7, 0);
	Cipher v9 = Cipher.getInstance("AES/GCM/NoPadding");
	GCMParameterSpec v9 = new GCMParameterSpec(128,v2);
	v9.init(2, v8, v9);
	byte[] v12 = v9.doFinal(v3);
	LockscreenCredential v13 = LockscreenCredential.createManagedPassword(v12);
	Arrays.fill(v12, 0);
	this.mManagedProfilePasswordCache.storePassword(p1, v13);
	return v13;
}
-----
depth : 2
public SyntheticPasswordManager$AuthenticationToken initializeSyntheticPasswordLocked(byte[] p1, LockscreenCredential p2, int p3){
	StringBuilder v0 = new StringBuilder();
	StringBuilder v2 = v0.append("Initialize SyntheticPassword for user: ");
	StringBuilder v3 = v0.append(p3);
	String v4 = v0.toString();
	int v5 = Slog.i("LockSettingsService", v4);
	long v6 = p0.getSyntheticPasswordHandleLocked(p3);
	Preconditions.checkState(phiInstruction, "Cannot reinitialize SP");
	IGateKeeperService v8 = p0.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationToken v9 = this.mSpManager.newSyntheticPasswordAndSid(v8, p1, p2, p3);
	IGateKeeperService v10 = p0.getGateKeeperService();
	long v11 = this.mSpManager.createPasswordBasedSyntheticPassword(v10, p2, v9, p3);
	boolean v12 = p2.isNone();
	IGateKeeperService v13 = p0.getGateKeeperService();
	this.mSpManager.newSidForUser(v13, v9, p3);
	IGateKeeperService v15 = p0.getGateKeeperService();
	VerifyCredentialResponse v16 = this.mSpManager.verifyChallenge(v15, v9, 0, p3);
	byte[] v17 = v9.deriveDiskEncryptionKey();
	p0.setUserKeyProtection(p3, v17);
	byte[] v19 = v9.deriveKeyStorePassword();
	p0.setKeystorePassword(v19, p3);
	p0.fixateNewestUserKeyAuth(p3);
	p0.setSyntheticPasswordHandleLocked(v11, p3);
	p0.onAuthTokenKnownForUser(p3, v9);
	return v9;
}
-----
depth : 2
public boolean spBasedSetLockCredentialInternalLocked(LockscreenCredential p1, LockscreenCredential p2, int p3, boolean p4){
	boolean v1 = p2.isNone();
	boolean v2 = p0.isProfileWithUnifiedLock(p3);
	LockscreenCredential v3 = p0.getDecryptedPasswordForTiedProfile(p3);
	int v4 = Slog.e("LockSettingsService", "Failed to decrypt child profile key", caughtException);
	long v5 = p0.getSyntheticPasswordHandleLocked(p3);
	IGateKeeperService v6 = p0.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v7 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v6, v5, phiInstruction, p3, 0);
	int v8 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	int v9 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	int v10 = Slog.w("LockSettingsService", "Failed to enroll: rate limit exceeded.");
	return 0;
}
-----
depth : 1
public void setSeparateProfileChallengeEnabledLocked(int p1, boolean p2, LockscreenCredential p3){
	boolean v1 = p0.getBoolean("lockscreen.profilechallenge", 0, p1);
	p0.setBoolean("lockscreen.profilechallenge", p2, p1);
	this.mStorage.removeChildProfileLock(p1);
	p0.removeKeystoreProfileKey(p1);
	return;
}
-----
depth : 2
public boolean getBoolean(String p1, boolean p2, int p3){
	p0.checkReadPermission(p1, p3);
	boolean v2 = "lock_pattern_autolock".equals(p1);
	int v3 = p0.getCredentialTypeInternal(p3);
	return phiInstruction;
}
-----
depth : 2
public void setBoolean(String p1, boolean p2, int p3){
	p0.checkWritePermission(p3);
	this.mStorage.setBoolean(p1, p2, p3);
	return;
}
-----
depth : 2
public void removeChildProfileLock(int p1){
	String v1 = p0.getChildProfileLockFile(p1);
	p0.deleteFile(v1);
	caughtException.printStackTrace();
	return;
}
-----
depth : 2
public void removeKeystoreProfileKey(int p1){
	StringBuilder v0 = new StringBuilder();
	StringBuilder v2 = v0.append("Remove keystore profile key for user: ");
	StringBuilder v3 = v0.append(p1);
	String v4 = v0.toString();
	int v5 = Slog.i("LockSettingsService", v4);
	StringBuilder v5 = new StringBuilder();
	StringBuilder v7 = v5.append("profile_key_name_encrypt_");
	StringBuilder v8 = v5.append(p1);
	String v9 = v5.toString();
	this.mJavaKeyStore.deleteEntry(v9);
	StringBuilder v10 = new StringBuilder();
	StringBuilder v12 = v10.append("profile_key_name_decrypt_");
	StringBuilder v13 = v10.append(p1);
	String v14 = v10.toString();
	this.mJavaKeyStore.deleteEntry(v14);
	StringBuilder v15 = new StringBuilder();
	StringBuilder v17 = v15.append("Unable to remove keystore profile key for user:");
	StringBuilder v18 = v15.append(p1);
	String v19 = v15.toString();
	int v20 = Slog.e("LockSettingsService", v19, caughtException);
	return;
}
-----
depth : 1
public boolean isCredentialSharableWithParent(int p1){
	UserManager v1 = p0.getUserManagerFromCache(p1);
	boolean v2 = v1.isCredentialSharableWithParent();
	return v2;
}
-----
depth : 2
public UserManager getUserManagerFromCache(int p1){
	UserHandle v1 = UserHandle.of(p1);
	boolean v2 = this.mUserManagerCache.containsKey(v1);
	Context v3 = this.mContext.createPackageContextAsUser("system", 0, v1);
	Object v4 = v3.getSystemService(UserManage.class);
	Object v5 = this.mUserManagerCache.put(v1, v4);
	return v4;
}
-----
depth : 1
public void setDeviceUnlockedForUser(int p1){
	Object v1 = this.mContext.getSystemService(TrustManage.class);
	v1.setDeviceLockedForUser(p1, 0);
	return;
}
-----
depth : 2
public void setDeviceLockedForUser(int p1, boolean p2){
	this.mService.setDeviceLockedForUser(p1, p2);
	return;
}
-----
depth : 1
public void onPostPasswordChanged(LockscreenCredential p1, int p2){
	boolean v1 = LockSettingsService.isDeviceEncryptionEnabled();
	boolean v2 = p0.shouldEncryptWithCredentials();
	boolean v3 = p1.isNone();
	p0.setCredentialRequiredToDecrypt(0);
	boolean v5 = p1.isPattern();
	p0.setBoolean("lockscreen.patterneverchosen", 1, p2);
	p0.updatePasswordHistory(p1, p2);
	Object v8 = this.mContext.getSystemService(TrustManage.class);
	v8.reportEnabledTrustAgentsChanged(p2);
	return;
}
-----
depth : 2
public boolean isDeviceEncryptionEnabled(){
	boolean v1 = StorageManager.isEncrypted();
	return v1;
}
-----
depth : 2
public boolean shouldEncryptWithCredentials(){
	boolean v1 = p0.isCredentialRequiredToDecrypt();
	boolean v2 = p0.isDoNotAskCredentialsOnBootSet();
	return phiInstruction;
}
-----
depth : 2
public void setCredentialRequiredToDecrypt(boolean p1){
	boolean v1 = LockSettingsService.isDeviceEncryptionEnabled();
	ContentResolver v2 = this.mContext.getContentResolver();
	boolean v3 = Settings$Global.putInt(v2, "require_password_to_decrypt", p1);
	return;
}
-----
depth : 2
public void setBoolean(String p1, boolean p2, int p3){
	p0.checkWritePermission(p3);
	this.mStorage.setBoolean(p1, p2, p3);
	return;
}
-----
depth : 2
public void updatePasswordHistory(LockscreenCredential p1, int p2){
	boolean v1 = p1.isNone();
	boolean v2 = p1.isPattern();
	String v3 = p0.getString("lockscreen.passwordhistory", 0, p2);
	int v4 = p0.getRequestedPasswordHistoryLength(p2);
	byte[] v5 = p0.getHashFactor(p1, p2);
	String v6 = p0.getSalt(p2);
	byte[] v7 = v6.getBytes();
	String v8 = p1.passwordToHistoryHash(v7, v5);
	int v9 = Slog.e("LockSettingsService", "Compute new style password hash failed, fallback to legacy style");
	String v10 = p1.legacyPasswordToHash(v7);
	boolean v11 = TextUtils.isEmpty(phiInstruction);
	String v12 = phiInstruction.split(",");
	StringJoiner v12 = new StringJoiner(",");
	StringJoiner v14 = v12.add(phiInstruction);
	String v15 = v12.toString();
	p0.setString("lockscreen.passwordhistory", phiInstruction, p2);
	return;
}
-----
depth : 2
public void reportEnabledTrustAgentsChanged(int p1){
	this.mService.reportEnabledTrustAgentsChanged(p1);
	return;
}
-----

This is path 2 for the API with depth 2:
depth : 0
public boolean setLockCredential(LockscreenCredential p1, LockscreenCredential p2, int p3){
	int v1 = p1.getType();
	boolean v2 = p0.hasPermission("android.permission.ACCESS_KEYGUARD_SECURE_STORAGE");
	boolean v3 = p0.hasPermission("android.permission.SET_AND_VERIFY_LOCKSCREEN_CREDENTIALS");
	boolean v4 = p0.hasPermission("android.permission.SET_INITIAL_LOCK");
	boolean v5 = p2.isNone();
	long v6 = Binder.clearCallingIdentity();
	p0.enforceFrpResolved();
	boolean v8 = p2.isNone();
	boolean v9 = p0.isProfileWithUnifiedLock(p3);
	UserInfo v10 = this.mUserManager.getProfileParent(p3);
	VerifyCredentialResponse v11 = p0.verifyCredential(p2, UserInfo.id, 0);
	p2.zeroize();
	LockscreenCredential v13 = LockscreenCredential.createNone();
	boolean v14 = p0.setLockCredentialInternal(p1, phiInstruction, p3, 0);
	p0.setSeparateProfileChallengeEnabledLocked(p3, 1, 0);
	p0.notifyPasswordChanged(p1, p3);
	boolean v17 = p0.isCredentialSharableWithParent(p3);
	p0.setDeviceUnlockedForUser(p3);
	p0.notifySeparateProfileChallengeChanged(p3);
	p0.onPostPasswordChanged(p1, p3);
	p0.scheduleGc();
	Binder.restoreCallingIdentity(v6);
	return 1;
}
-----
depth : 1
public int getType(){
	p0.ensureNotZeroized();
	return this.mType;
}
-----
depth : 2
public void ensureNotZeroized(){
	Preconditions.checkState(phiInstruction, "Credential is already zeroized");
	return;
}
-----
depth : 1
public void enforceFrpResolved(){
	ContentResolver v1 = this.mContext.getContentResolver();
	int v2 = this.mInjector.settingsSecureGetInt(v1, "user_setup_complete", 0, 0);
	int v3 = this.mInjector.settingsSecureGetInt(v1, "secure_frp_mode", 0, 0);
	return;
}
-----
depth : 2
public int settingsSecureGetInt(ContentResolver p1, String p2, int p3, int p4){
	int v1 = Settings$Secure.getIntForUser(p1, p2, p3, p4);
	return v1;
}
-----
depth : 2
public int settingsSecureGetInt(ContentResolver p1, String p2, int p3, int p4){
	int v1 = Settings$Secure.getIntForUser(p1, p2, p3, p4);
	return v1;
}
-----
depth : 1
public boolean isProfileWithUnifiedLock(int p1){
	boolean v1 = p0.isCredentialSharableWithParent(p1);
	boolean v2 = p0.getSeparateProfileChallengeEnabledInternal(p1);
	return phiInstruction;
}
-----
depth : 2
public boolean isCredentialSharableWithParent(int p1){
	UserManager v1 = p0.getUserManagerFromCache(p1);
	boolean v2 = v1.isCredentialSharableWithParent();
	return v2;
}
-----
depth : 2
public boolean getSeparateProfileChallengeEnabledInternal(int p1){
	boolean v1 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
	return v1;
}
-----
depth : 1
public VerifyCredentialResponse verifyCredential(LockscreenCredential p1, int p2, int p3){
	boolean v1 = p0.hasPermission("android.permission.ACCESS_KEYGUARD_SECURE_STORAGE");
	boolean v2 = p0.hasPermission("android.permission.SET_AND_VERIFY_LOCKSCREEN_CREDENTIALS");
	long v3 = Binder.clearCallingIdentity();
	VerifyCredentialResponse v4 = p0.doVerifyCredential(p1, p2, 0, p3);
	Binder.restoreCallingIdentity(v3);
	p0.scheduleGc();
	return v4;
}
-----
depth : 2
public boolean hasPermission(String p1){
	return phiInstruction;
}
-----
depth : 2
public boolean hasPermission(String p1){
	return phiInstruction;
}
-----
depth : 2
public VerifyCredentialResponse doVerifyCredential(LockscreenCredential p1, int p2, ICheckCredentialProgressCallback p3, int p4){
	boolean v1 = p1.isNone();
	ContentResolver v2 = this.mContext.getContentResolver();
	int v3 = this.mInjector.settingsGlobalGetInt(v2, "device_provisioned", 0);
	VerifyCredentialResponse v4 = p0.spBasedDoVerifyCredential(p1, p2, p3, p4);
	LockSettingsStorage$CredentialHash v5 = this.mStorage.readCredentialHash(p2);
	boolean v6 = p1.checkAgainstStoredType(LockSettingsStorage$CredentialHash.type);
	StringBuilder v6 = new StringBuilder();
	StringBuilder v8 = v6.append("doVerifyCredential type mismatch with stored credential?? stored: ");
	StringBuilder v9 = v6.append(LockSettingsStorage$CredentialHash.type);
	StringBuilder v10 = v6.append(" passed in: ");
	int v11 = p1.getType();
	StringBuilder v12 = v6.append(v11);
	String v13 = v6.toString();
	int v14 = Slog.wtf("LockSettingsService", v13);
	return VerifyCredentialResponse.ERROR;
}
-----
depth : 2
public void scheduleGc(){
	LockSettingsService$$ExternalSyntheticLambda3 v0 = new LockSettingsService$$ExternalSyntheticLambda3();
	boolean v2 = this.mHandler.postDelayed(v0, 2000);
	return;
}
-----
depth : 1
public boolean setLockCredentialInternal(LockscreenCredential p1, LockscreenCredential p2, int p3, boolean p4){
	Object v1 = Objects.requireNonNull(p1);
	Object v2 = Objects.requireNonNull(p2);
	boolean v3 = p0.isSyntheticPasswordBasedCredentialLocked(p3);
	boolean v4 = p1.isNone();
	LockSettingsStorage$CredentialHash v5 = this.mStorage.readCredentialHash(p3);
	boolean v6 = p0.isProfileWithUnifiedLock(p3);
	boolean v7 = p2.isNone();
	LockscreenCredential v8 = p0.getDecryptedPasswordForTiedProfile(p3);
	int v9 = Slog.e("LockSettingsService", "Failed to decrypt child profile key", caughtException);
	SyntheticPasswordManager$AuthenticationToken v10 = p0.initializeSyntheticPasswordLocked(LockSettingsStorage$CredentialHash.hash, phiInstruction, p3);
	boolean v11 = p0.spBasedSetLockCredentialInternalLocked(p1, phiInstruction, p3, p4);
	return v11;
}
-----
depth : 2
public boolean isSyntheticPasswordBasedCredentialLocked(int p1){
	LockSettingsStorage$PersistentData v1 = this.mStorage.readPersistentDataBlock();
	return phiInstruction;
}
-----
depth : 2
public LockSettingsStorage$CredentialHash readCredentialHash(int p1){
	LockSettingsStorage$CredentialHash v1 = p0.readPasswordHashIfExists(p1);
	LockSettingsStorage$CredentialHash v2 = p0.readPatternHashIfExists(p1);
	LockSettingsStorage$CredentialHash v3 = LockSettingsStorage$CredentialHash.createEmptyHash();
	return v3;
}
-----
depth : 2
public boolean isProfileWithUnifiedLock(int p1){
	boolean v1 = p0.isCredentialSharableWithParent(p1);
	boolean v2 = p0.getSeparateProfileChallengeEnabledInternal(p1);
	return phiInstruction;
}
-----
depth : 2
public LockscreenCredential getDecryptedPasswordForTiedProfile(int p1){
	byte[] v1 = this.mStorage.readChildProfileLock(p1);
	byte[] v2 = Arrays.copyOfRange(v1, 0, 12);
	byte[] v3 = Arrays.copyOfRange(v1, 12, v1.length);
	StringBuilder v3 = new StringBuilder();
	StringBuilder v5 = v3.append("profile_key_name_decrypt_");
	StringBuilder v6 = v3.append(p1);
	String v7 = v3.toString();
	Key v8 = this.mJavaKeyStore.getKey(v7, 0);
	Cipher v9 = Cipher.getInstance("AES/GCM/NoPadding");
	GCMParameterSpec v9 = new GCMParameterSpec(128,v2);
	v9.init(2, v8, v9);
	byte[] v12 = v9.doFinal(v3);
	LockscreenCredential v13 = LockscreenCredential.createManagedPassword(v12);
	Arrays.fill(v12, 0);
	this.mManagedProfilePasswordCache.storePassword(p1, v13);
	return v13;
}
-----
depth : 2
public SyntheticPasswordManager$AuthenticationToken initializeSyntheticPasswordLocked(byte[] p1, LockscreenCredential p2, int p3){
	StringBuilder v0 = new StringBuilder();
	StringBuilder v2 = v0.append("Initialize SyntheticPassword for user: ");
	StringBuilder v3 = v0.append(p3);
	String v4 = v0.toString();
	int v5 = Slog.i("LockSettingsService", v4);
	long v6 = p0.getSyntheticPasswordHandleLocked(p3);
	Preconditions.checkState(phiInstruction, "Cannot reinitialize SP");
	IGateKeeperService v8 = p0.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationToken v9 = this.mSpManager.newSyntheticPasswordAndSid(v8, p1, p2, p3);
	IGateKeeperService v10 = p0.getGateKeeperService();
	long v11 = this.mSpManager.createPasswordBasedSyntheticPassword(v10, p2, v9, p3);
	boolean v12 = p2.isNone();
	IGateKeeperService v13 = p0.getGateKeeperService();
	this.mSpManager.newSidForUser(v13, v9, p3);
	IGateKeeperService v15 = p0.getGateKeeperService();
	VerifyCredentialResponse v16 = this.mSpManager.verifyChallenge(v15, v9, 0, p3);
	byte[] v17 = v9.deriveDiskEncryptionKey();
	p0.setUserKeyProtection(p3, v17);
	byte[] v19 = v9.deriveKeyStorePassword();
	p0.setKeystorePassword(v19, p3);
	p0.fixateNewestUserKeyAuth(p3);
	p0.setSyntheticPasswordHandleLocked(v11, p3);
	p0.onAuthTokenKnownForUser(p3, v9);
	return v9;
}
-----
depth : 2
public boolean spBasedSetLockCredentialInternalLocked(LockscreenCredential p1, LockscreenCredential p2, int p3, boolean p4){
	boolean v1 = p2.isNone();
	boolean v2 = p0.isProfileWithUnifiedLock(p3);
	LockscreenCredential v3 = p0.getDecryptedPasswordForTiedProfile(p3);
	int v4 = Slog.e("LockSettingsService", "Failed to decrypt child profile key", caughtException);
	long v5 = p0.getSyntheticPasswordHandleLocked(p3);
	IGateKeeperService v6 = p0.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v7 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v6, v5, phiInstruction, p3, 0);
	int v8 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	int v9 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	int v10 = Slog.w("LockSettingsService", "Failed to enroll: rate limit exceeded.");
	return 0;
}
-----
depth : 1
public void setSeparateProfileChallengeEnabledLocked(int p1, boolean p2, LockscreenCredential p3){
	boolean v1 = p0.getBoolean("lockscreen.profilechallenge", 0, p1);
	p0.setBoolean("lockscreen.profilechallenge", p2, p1);
	this.mStorage.removeChildProfileLock(p1);
	p0.removeKeystoreProfileKey(p1);
	return;
}
-----
depth : 2
public boolean getBoolean(String p1, boolean p2, int p3){
	p0.checkReadPermission(p1, p3);
	boolean v2 = "lock_pattern_autolock".equals(p1);
	int v3 = p0.getCredentialTypeInternal(p3);
	return phiInstruction;
}
-----
depth : 2
public void setBoolean(String p1, boolean p2, int p3){
	p0.checkWritePermission(p3);
	this.mStorage.setBoolean(p1, p2, p3);
	return;
}
-----
depth : 2
public void removeChildProfileLock(int p1){
	String v1 = p0.getChildProfileLockFile(p1);
	p0.deleteFile(v1);
	caughtException.printStackTrace();
	return;
}
-----
depth : 2
public void removeKeystoreProfileKey(int p1){
	StringBuilder v0 = new StringBuilder();
	StringBuilder v2 = v0.append("Remove keystore profile key for user: ");
	StringBuilder v3 = v0.append(p1);
	String v4 = v0.toString();
	int v5 = Slog.i("LockSettingsService", v4);
	StringBuilder v5 = new StringBuilder();
	StringBuilder v7 = v5.append("profile_key_name_encrypt_");
	StringBuilder v8 = v5.append(p1);
	String v9 = v5.toString();
	this.mJavaKeyStore.deleteEntry(v9);
	StringBuilder v10 = new StringBuilder();
	StringBuilder v12 = v10.append("profile_key_name_decrypt_");
	StringBuilder v13 = v10.append(p1);
	String v14 = v10.toString();
	this.mJavaKeyStore.deleteEntry(v14);
	StringBuilder v15 = new StringBuilder();
	StringBuilder v17 = v15.append("Unable to remove keystore profile key for user:");
	StringBuilder v18 = v15.append(p1);
	String v19 = v15.toString();
	int v20 = Slog.e("LockSettingsService", v19, caughtException);
	return;
}
-----
depth : 1
public boolean isCredentialSharableWithParent(int p1){
	UserManager v1 = p0.getUserManagerFromCache(p1);
	boolean v2 = v1.isCredentialSharableWithParent();
	return v2;
}
-----
depth : 2
public UserManager getUserManagerFromCache(int p1){
	UserHandle v1 = UserHandle.of(p1);
	boolean v2 = this.mUserManagerCache.containsKey(v1);
	Context v3 = this.mContext.createPackageContextAsUser("system", 0, v1);
	Object v4 = v3.getSystemService(UserManage.class);
	Object v5 = this.mUserManagerCache.put(v1, v4);
	return v4;
}
-----
depth : 1
public void setDeviceUnlockedForUser(int p1){
	Object v1 = this.mContext.getSystemService(TrustManage.class);
	v1.setDeviceLockedForUser(p1, 0);
	return;
}
-----
depth : 2
public void setDeviceLockedForUser(int p1, boolean p2){
	this.mService.setDeviceLockedForUser(p1, p2);
	return;
}
-----
depth : 1
public void onPostPasswordChanged(LockscreenCredential p1, int p2){
	boolean v1 = LockSettingsService.isDeviceEncryptionEnabled();
	boolean v2 = p0.shouldEncryptWithCredentials();
	boolean v3 = p1.isNone();
	p0.setCredentialRequiredToDecrypt(0);
	boolean v5 = p1.isPattern();
	p0.setBoolean("lockscreen.patterneverchosen", 1, p2);
	p0.updatePasswordHistory(p1, p2);
	Object v8 = this.mContext.getSystemService(TrustManage.class);
	v8.reportEnabledTrustAgentsChanged(p2);
	return;
}
-----
depth : 2
public boolean isDeviceEncryptionEnabled(){
	boolean v1 = StorageManager.isEncrypted();
	return v1;
}
-----
depth : 2
public boolean shouldEncryptWithCredentials(){
	boolean v1 = p0.isCredentialRequiredToDecrypt();
	boolean v2 = p0.isDoNotAskCredentialsOnBootSet();
	return phiInstruction;
}
-----
depth : 2
public void setCredentialRequiredToDecrypt(boolean p1){
	boolean v1 = LockSettingsService.isDeviceEncryptionEnabled();
	ContentResolver v2 = this.mContext.getContentResolver();
	boolean v3 = Settings$Global.putInt(v2, "require_password_to_decrypt", p1);
	return;
}
-----
depth : 2
public void setBoolean(String p1, boolean p2, int p3){
	p0.checkWritePermission(p3);
	this.mStorage.setBoolean(p1, p2, p3);
	return;
}
-----
depth : 2
public void updatePasswordHistory(LockscreenCredential p1, int p2){
	boolean v1 = p1.isNone();
	boolean v2 = p1.isPattern();
	String v3 = p0.getString("lockscreen.passwordhistory", 0, p2);
	int v4 = p0.getRequestedPasswordHistoryLength(p2);
	byte[] v5 = p0.getHashFactor(p1, p2);
	String v6 = p0.getSalt(p2);
	byte[] v7 = v6.getBytes();
	String v8 = p1.passwordToHistoryHash(v7, v5);
	int v9 = Slog.e("LockSettingsService", "Compute new style password hash failed, fallback to legacy style");
	String v10 = p1.legacyPasswordToHash(v7);
	boolean v11 = TextUtils.isEmpty(phiInstruction);
	String v12 = phiInstruction.split(",");
	StringJoiner v12 = new StringJoiner(",");
	StringJoiner v14 = v12.add(phiInstruction);
	String v15 = v12.toString();
	p0.setString("lockscreen.passwordhistory", phiInstruction, p2);
	return;
}
-----
depth : 2
public void reportEnabledTrustAgentsChanged(int p1){
	this.mService.reportEnabledTrustAgentsChanged(p1);
	return;
}
-----

This is path 3 for the API with depth 2:
depth : 0
public boolean setLockCredential(LockscreenCredential p1, LockscreenCredential p2, int p3){
	int v1 = p1.getType();
	boolean v2 = p0.hasPermission("android.permission.ACCESS_KEYGUARD_SECURE_STORAGE");
	boolean v3 = p0.hasPermission("android.permission.SET_AND_VERIFY_LOCKSCREEN_CREDENTIALS");
	boolean v4 = p0.hasPermission("android.permission.SET_INITIAL_LOCK");
	boolean v5 = p2.isNone();
	long v6 = Binder.clearCallingIdentity();
	p0.enforceFrpResolved();
	boolean v8 = p2.isNone();
	boolean v9 = p0.isProfileWithUnifiedLock(p3);
	UserInfo v10 = this.mUserManager.getProfileParent(p3);
	VerifyCredentialResponse v11 = p0.verifyCredential(p2, UserInfo.id, 0);
	p2.zeroize();
	LockscreenCredential v13 = LockscreenCredential.createNone();
	boolean v14 = p0.setLockCredentialInternal(p1, phiInstruction, p3, 0);
	p0.setSeparateProfileChallengeEnabledLocked(p3, 1, 0);
	p0.notifyPasswordChanged(p1, p3);
	boolean v17 = p0.isCredentialSharableWithParent(p3);
	p0.setDeviceUnlockedForUser(p3);
	p0.notifySeparateProfileChallengeChanged(p3);
	p0.onPostPasswordChanged(p1, p3);
	p0.scheduleGc();
	Binder.restoreCallingIdentity(v6);
	return 1;
}
-----
depth : 1
public int getType(){
	p0.ensureNotZeroized();
	return this.mType;
}
-----
depth : 2
public void ensureNotZeroized(){
	Preconditions.checkState(phiInstruction, "Credential is already zeroized");
	return;
}
-----
depth : 1
public void enforceFrpResolved(){
	ContentResolver v1 = this.mContext.getContentResolver();
	int v2 = this.mInjector.settingsSecureGetInt(v1, "user_setup_complete", 0, 0);
	int v3 = this.mInjector.settingsSecureGetInt(v1, "secure_frp_mode", 0, 0);
	return;
}
-----
depth : 2
public int settingsSecureGetInt(ContentResolver p1, String p2, int p3, int p4){
	int v1 = Settings$Secure.getIntForUser(p1, p2, p3, p4);
	return v1;
}
-----
depth : 2
public int settingsSecureGetInt(ContentResolver p1, String p2, int p3, int p4){
	int v1 = Settings$Secure.getIntForUser(p1, p2, p3, p4);
	return v1;
}
-----
depth : 1
public boolean isProfileWithUnifiedLock(int p1){
	boolean v1 = p0.isCredentialSharableWithParent(p1);
	boolean v2 = p0.getSeparateProfileChallengeEnabledInternal(p1);
	return phiInstruction;
}
-----
depth : 2
public boolean isCredentialSharableWithParent(int p1){
	UserManager v1 = p0.getUserManagerFromCache(p1);
	boolean v2 = v1.isCredentialSharableWithParent();
	return v2;
}
-----
depth : 2
public boolean getSeparateProfileChallengeEnabledInternal(int p1){
	boolean v1 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
	return v1;
}
-----
depth : 1
public VerifyCredentialResponse verifyCredential(LockscreenCredential p1, int p2, int p3){
	boolean v1 = p0.hasPermission("android.permission.ACCESS_KEYGUARD_SECURE_STORAGE");
	boolean v2 = p0.hasPermission("android.permission.SET_AND_VERIFY_LOCKSCREEN_CREDENTIALS");
	long v3 = Binder.clearCallingIdentity();
	VerifyCredentialResponse v4 = p0.doVerifyCredential(p1, p2, 0, p3);
	Binder.restoreCallingIdentity(v3);
	p0.scheduleGc();
	return v4;
}
-----
depth : 2
public boolean hasPermission(String p1){
	return phiInstruction;
}
-----
depth : 2
public boolean hasPermission(String p1){
	return phiInstruction;
}
-----
depth : 2
public VerifyCredentialResponse doVerifyCredential(LockscreenCredential p1, int p2, ICheckCredentialProgressCallback p3, int p4){
	boolean v1 = p1.isNone();
	ContentResolver v2 = this.mContext.getContentResolver();
	int v3 = this.mInjector.settingsGlobalGetInt(v2, "device_provisioned", 0);
	VerifyCredentialResponse v4 = p0.spBasedDoVerifyCredential(p1, p2, p3, p4);
	LockSettingsStorage$CredentialHash v5 = this.mStorage.readCredentialHash(p2);
	boolean v6 = p1.checkAgainstStoredType(LockSettingsStorage$CredentialHash.type);
	StringBuilder v6 = new StringBuilder();
	StringBuilder v8 = v6.append("doVerifyCredential type mismatch with stored credential?? stored: ");
	StringBuilder v9 = v6.append(LockSettingsStorage$CredentialHash.type);
	StringBuilder v10 = v6.append(" passed in: ");
	int v11 = p1.getType();
	StringBuilder v12 = v6.append(v11);
	String v13 = v6.toString();
	int v14 = Slog.wtf("LockSettingsService", v13);
	return VerifyCredentialResponse.ERROR;
}
-----
depth : 2
public void scheduleGc(){
	LockSettingsService$$ExternalSyntheticLambda3 v0 = new LockSettingsService$$ExternalSyntheticLambda3();
	boolean v2 = this.mHandler.postDelayed(v0, 2000);
	return;
}
-----
depth : 1
public boolean setLockCredentialInternal(LockscreenCredential p1, LockscreenCredential p2, int p3, boolean p4){
	Object v1 = Objects.requireNonNull(p1);
	Object v2 = Objects.requireNonNull(p2);
	boolean v3 = p0.isSyntheticPasswordBasedCredentialLocked(p3);
	boolean v4 = p1.isNone();
	LockSettingsStorage$CredentialHash v5 = this.mStorage.readCredentialHash(p3);
	boolean v6 = p0.isProfileWithUnifiedLock(p3);
	boolean v7 = p2.isNone();
	LockscreenCredential v8 = p0.getDecryptedPasswordForTiedProfile(p3);
	int v9 = Slog.e("LockSettingsService", "Failed to decrypt child profile key", caughtException);
	SyntheticPasswordManager$AuthenticationToken v10 = p0.initializeSyntheticPasswordLocked(LockSettingsStorage$CredentialHash.hash, phiInstruction, p3);
	boolean v11 = p0.spBasedSetLockCredentialInternalLocked(p1, phiInstruction, p3, p4);
	return v11;
}
-----
depth : 2
public boolean isSyntheticPasswordBasedCredentialLocked(int p1){
	LockSettingsStorage$PersistentData v1 = this.mStorage.readPersistentDataBlock();
	return phiInstruction;
}
-----
depth : 2
public LockSettingsStorage$CredentialHash readCredentialHash(int p1){
	LockSettingsStorage$CredentialHash v1 = p0.readPasswordHashIfExists(p1);
	LockSettingsStorage$CredentialHash v2 = p0.readPatternHashIfExists(p1);
	LockSettingsStorage$CredentialHash v3 = LockSettingsStorage$CredentialHash.createEmptyHash();
	return v3;
}
-----
depth : 2
public boolean isProfileWithUnifiedLock(int p1){
	boolean v1 = p0.isCredentialSharableWithParent(p1);
	boolean v2 = p0.getSeparateProfileChallengeEnabledInternal(p1);
	return phiInstruction;
}
-----
depth : 2
public LockscreenCredential getDecryptedPasswordForTiedProfile(int p1){
	byte[] v1 = this.mStorage.readChildProfileLock(p1);
	byte[] v2 = Arrays.copyOfRange(v1, 0, 12);
	byte[] v3 = Arrays.copyOfRange(v1, 12, v1.length);
	StringBuilder v3 = new StringBuilder();
	StringBuilder v5 = v3.append("profile_key_name_decrypt_");
	StringBuilder v6 = v3.append(p1);
	String v7 = v3.toString();
	Key v8 = this.mJavaKeyStore.getKey(v7, 0);
	Cipher v9 = Cipher.getInstance("AES/GCM/NoPadding");
	GCMParameterSpec v9 = new GCMParameterSpec(128,v2);
	v9.init(2, v8, v9);
	byte[] v12 = v9.doFinal(v3);
	LockscreenCredential v13 = LockscreenCredential.createManagedPassword(v12);
	Arrays.fill(v12, 0);
	this.mManagedProfilePasswordCache.storePassword(p1, v13);
	return v13;
}
-----
depth : 2
public SyntheticPasswordManager$AuthenticationToken initializeSyntheticPasswordLocked(byte[] p1, LockscreenCredential p2, int p3){
	StringBuilder v0 = new StringBuilder();
	StringBuilder v2 = v0.append("Initialize SyntheticPassword for user: ");
	StringBuilder v3 = v0.append(p3);
	String v4 = v0.toString();
	int v5 = Slog.i("LockSettingsService", v4);
	long v6 = p0.getSyntheticPasswordHandleLocked(p3);
	Preconditions.checkState(phiInstruction, "Cannot reinitialize SP");
	IGateKeeperService v8 = p0.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationToken v9 = this.mSpManager.newSyntheticPasswordAndSid(v8, p1, p2, p3);
	IGateKeeperService v10 = p0.getGateKeeperService();
	long v11 = this.mSpManager.createPasswordBasedSyntheticPassword(v10, p2, v9, p3);
	boolean v12 = p2.isNone();
	IGateKeeperService v13 = p0.getGateKeeperService();
	this.mSpManager.newSidForUser(v13, v9, p3);
	IGateKeeperService v15 = p0.getGateKeeperService();
	VerifyCredentialResponse v16 = this.mSpManager.verifyChallenge(v15, v9, 0, p3);
	byte[] v17 = v9.deriveDiskEncryptionKey();
	p0.setUserKeyProtection(p3, v17);
	byte[] v19 = v9.deriveKeyStorePassword();
	p0.setKeystorePassword(v19, p3);
	p0.fixateNewestUserKeyAuth(p3);
	p0.setSyntheticPasswordHandleLocked(v11, p3);
	p0.onAuthTokenKnownForUser(p3, v9);
	return v9;
}
-----
depth : 2
public boolean spBasedSetLockCredentialInternalLocked(LockscreenCredential p1, LockscreenCredential p2, int p3, boolean p4){
	boolean v1 = p2.isNone();
	boolean v2 = p0.isProfileWithUnifiedLock(p3);
	LockscreenCredential v3 = p0.getDecryptedPasswordForTiedProfile(p3);
	int v4 = Slog.e("LockSettingsService", "Failed to decrypt child profile key", caughtException);
	long v5 = p0.getSyntheticPasswordHandleLocked(p3);
	IGateKeeperService v6 = p0.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v7 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v6, v5, phiInstruction, p3, 0);
	int v8 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	int v9 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	int v10 = Slog.w("LockSettingsService", "Failed to enroll: rate limit exceeded.");
	return 0;
}
-----
depth : 1
public void setSeparateProfileChallengeEnabledLocked(int p1, boolean p2, LockscreenCredential p3){
	boolean v1 = p0.getBoolean("lockscreen.profilechallenge", 0, p1);
	p0.setBoolean("lockscreen.profilechallenge", p2, p1);
	this.mStorage.removeChildProfileLock(p1);
	p0.removeKeystoreProfileKey(p1);
	return;
}
-----
depth : 2
public boolean getBoolean(String p1, boolean p2, int p3){
	p0.checkReadPermission(p1, p3);
	boolean v2 = "lock_pattern_autolock".equals(p1);
	int v3 = p0.getCredentialTypeInternal(p3);
	return phiInstruction;
}
-----
depth : 2
public void setBoolean(String p1, boolean p2, int p3){
	p0.checkWritePermission(p3);
	this.mStorage.setBoolean(p1, p2, p3);
	return;
}
-----
depth : 2
public void removeChildProfileLock(int p1){
	String v1 = p0.getChildProfileLockFile(p1);
	p0.deleteFile(v1);
	caughtException.printStackTrace();
	return;
}
-----
depth : 2
public void removeKeystoreProfileKey(int p1){
	StringBuilder v0 = new StringBuilder();
	StringBuilder v2 = v0.append("Remove keystore profile key for user: ");
	StringBuilder v3 = v0.append(p1);
	String v4 = v0.toString();
	int v5 = Slog.i("LockSettingsService", v4);
	StringBuilder v5 = new StringBuilder();
	StringBuilder v7 = v5.append("profile_key_name_encrypt_");
	StringBuilder v8 = v5.append(p1);
	String v9 = v5.toString();
	this.mJavaKeyStore.deleteEntry(v9);
	StringBuilder v10 = new StringBuilder();
	StringBuilder v12 = v10.append("profile_key_name_decrypt_");
	StringBuilder v13 = v10.append(p1);
	String v14 = v10.toString();
	this.mJavaKeyStore.deleteEntry(v14);
	StringBuilder v15 = new StringBuilder();
	StringBuilder v17 = v15.append("Unable to remove keystore profile key for user:");
	StringBuilder v18 = v15.append(p1);
	String v19 = v15.toString();
	int v20 = Slog.e("LockSettingsService", v19, caughtException);
	return;
}
-----
depth : 1
public boolean isCredentialSharableWithParent(int p1){
	UserManager v1 = p0.getUserManagerFromCache(p1);
	boolean v2 = v1.isCredentialSharableWithParent();
	return v2;
}
-----
depth : 2
public UserManager getUserManagerFromCache(int p1){
	UserHandle v1 = UserHandle.of(p1);
	boolean v2 = this.mUserManagerCache.containsKey(v1);
	Context v3 = this.mContext.createPackageContextAsUser("system", 0, v1);
	Object v4 = v3.getSystemService(UserManage.class);
	Object v5 = this.mUserManagerCache.put(v1, v4);
	return v4;
}
-----
depth : 1
public void setDeviceUnlockedForUser(int p1){
	Object v1 = this.mContext.getSystemService(TrustManage.class);
	v1.setDeviceLockedForUser(p1, 0);
	return;
}
-----
depth : 2
public void setDeviceLockedForUser(int p1, boolean p2){
	this.mService.setDeviceLockedForUser(p1, p2);
	return;
}
-----
depth : 1
public void onPostPasswordChanged(LockscreenCredential p1, int p2){
	boolean v1 = LockSettingsService.isDeviceEncryptionEnabled();
	boolean v2 = p0.shouldEncryptWithCredentials();
	boolean v3 = p1.isNone();
	p0.setCredentialRequiredToDecrypt(0);
	boolean v5 = p1.isPattern();
	p0.setBoolean("lockscreen.patterneverchosen", 1, p2);
	p0.updatePasswordHistory(p1, p2);
	Object v8 = this.mContext.getSystemService(TrustManage.class);
	v8.reportEnabledTrustAgentsChanged(p2);
	return;
}
-----
depth : 2
public boolean isDeviceEncryptionEnabled(){
	boolean v1 = StorageManager.isEncrypted();
	return v1;
}
-----
depth : 2
public boolean shouldEncryptWithCredentials(){
	boolean v1 = p0.isCredentialRequiredToDecrypt();
	boolean v2 = p0.isDoNotAskCredentialsOnBootSet();
	return phiInstruction;
}
-----
depth : 2
public void setCredentialRequiredToDecrypt(boolean p1){
	boolean v1 = LockSettingsService.isDeviceEncryptionEnabled();
	ContentResolver v2 = this.mContext.getContentResolver();
	boolean v3 = Settings$Global.putInt(v2, "require_password_to_decrypt", p1);
	return;
}
-----
depth : 2
public void setBoolean(String p1, boolean p2, int p3){
	p0.checkWritePermission(p3);
	this.mStorage.setBoolean(p1, p2, p3);
	return;
}
-----
depth : 2
public void updatePasswordHistory(LockscreenCredential p1, int p2){
	boolean v1 = p1.isNone();
	boolean v2 = p1.isPattern();
	String v3 = p0.getString("lockscreen.passwordhistory", 0, p2);
	int v4 = p0.getRequestedPasswordHistoryLength(p2);
	byte[] v5 = p0.getHashFactor(p1, p2);
	String v6 = p0.getSalt(p2);
	byte[] v7 = v6.getBytes();
	String v8 = p1.passwordToHistoryHash(v7, v5);
	int v9 = Slog.e("LockSettingsService", "Compute new style password hash failed, fallback to legacy style");
	String v10 = p1.legacyPasswordToHash(v7);
	boolean v11 = TextUtils.isEmpty(phiInstruction);
	String v12 = phiInstruction.split(",");
	StringJoiner v12 = new StringJoiner(",");
	StringJoiner v14 = v12.add(phiInstruction);
	String v15 = v12.toString();
	p0.setString("lockscreen.passwordhistory", phiInstruction, p2);
	return;
}
-----
depth : 2
public void reportEnabledTrustAgentsChanged(int p1){
	this.mService.reportEnabledTrustAgentsChanged(p1);
	return;
}
-----
