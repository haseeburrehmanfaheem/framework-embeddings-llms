The method setDeviceLockedForUser has the following code snippet:

This is path 1 for the API with depth 2:
public void setDeviceLockedForUser(int p1, boolean p2){
	long v2 = Binder.clearCallingIdentity();
	LockPatternUtils v3 = this.mLockPatternUtils;
	boolean v4 = v3.isSeparateProfileChallengeEnabled(p1);
	if (v4 == 0) {
		LockPatternUtils v5 = this.mLockPatternUtils;
		boolean v6 = v5.isSecure(p1);
		if (v6 == 0) {
			SparseBooleanArray v7 = this.mDeviceLockedForUser;
			SparseBooleanArray v8 = this.mDeviceLockedForUser;
			v8.put(p1, p2);
			Object v12 = this.mContext.getSystemService(BiometricManage.class);
			if (v12 != 0) {
				[J v13 = v12.getAuthenticatorIds(p1);
				[J v11 = v13;
				[J v10 = v11;
				if (p2 == 0) {
					IBinder v16 = ServiceManager.checkService("android.security.authorization");
					IKeystoreAuthorization v17 = IKeystoreAuthorization$Stub.asInterface(v16);
					IKeystoreAuthorization v15 = v17;
					v15.onLockScreenEvent(1, p1, 0, v10);
					int v14 = ServiceSpecificException.errorCode;
					if (p2 == 0) {
						IActivityManager v19 = ActivityManager.getService();
						v19.notifyLockedProfile(p1);
						Intent v21 = new Intent("android.intent.action.DEVICE_LOCKED_CHANGED");
						Intent v23 = v21.addFlags(1073741824);
						Intent v24 = v21.putExtra("android.intent.extra.user_handle", p1);
						Context v25 = TrustManagerService.-$$Nest$fgetmContext(this.this$0);
						v25.sendBroadcastAsUser(v21, UserHandle.SYSTEM, "android.permission.TRUST_LISTENER", 0);
						Binder.restoreCallingIdentity(v2);
						return;
					}
				}
			}
		}
	}
}


This is path 2 for the API with depth 1:
public void setDeviceLockedForUser(int p1, boolean p2){
	long v2 = Binder.clearCallingIdentity();
	LockPatternUtils v3 = this.mLockPatternUtils;
	boolean v4 = v3.isSeparateProfileChallengeEnabled(p1);
	if (v4 == 0) {
		LockPatternUtils v5 = this.mLockPatternUtils;
		boolean v6 = v5.isSecure(p1);
		if (v6 == 0) {
			SparseBooleanArray v7 = this.mDeviceLockedForUser;
			SparseBooleanArray v8 = this.mDeviceLockedForUser;
			v8.put(p1, p2);
			[J v11 = this.this$0.getBiometricSids(p1);
			[J v10 = v11;
			if (p2 == 0) {
				IKeystoreAuthorization v13 = Authorization.getService();
				v13.onLockScreenEvent(1, p1, 0, v10);
				int v12 = ServiceSpecificException.errorCode;
				if (p2 == 0) {
					IActivityManager v15 = ActivityManager.getService();
					v15.notifyLockedProfile(p1);
					Intent v17 = new Intent("android.intent.action.DEVICE_LOCKED_CHANGED");
					Intent v19 = v17.addFlags(1073741824);
					Intent v20 = v17.putExtra("android.intent.extra.user_handle", p1);
					Context v21 = this.mContext;
					v21.sendBroadcastAsUser(v17, UserHandle.SYSTEM, "android.permission.TRUST_LISTENER", 0);
					Binder.restoreCallingIdentity(v2);
					return;
				}
			}
		}
	}
}


This is path 3 for the API with depth 0:
public void setDeviceLockedForUser(int p1, boolean p2){
	long v2 = Binder.clearCallingIdentity();
	LockPatternUtils v3 = TrustManagerService.-$$Nest$fgetmLockPatternUtils(this.this$0);
	boolean v4 = v3.isSeparateProfileChallengeEnabled(p1);
	if (v4 == 0) {
		LockPatternUtils v5 = TrustManagerService.-$$Nest$fgetmLockPatternUtils(this.this$0);
		boolean v6 = v5.isSecure(p1);
		if (v6 == 0) {
			SparseBooleanArray v7 = TrustManagerService.-$$Nest$fgetmDeviceLockedForUser(this.this$0);
			SparseBooleanArray v8 = TrustManagerService.-$$Nest$fgetmDeviceLockedForUser(this.this$0);
			v8.put(p1, p2);
			[J v10 = TrustManagerService.-$$Nest$mgetBiometricSids(this.this$0, p1);
			int v11 = Authorization.onLockScreenEvent(p2, p1, 0, v10);
			if (p2 == 0) {
				IActivityManager v12 = ActivityManager.getService();
				v12.notifyLockedProfile(p1);
				Intent v14 = new Intent("android.intent.action.DEVICE_LOCKED_CHANGED");
				Intent v16 = v14.addFlags(1073741824);
				Intent v17 = v14.putExtra("android.intent.extra.user_handle", p1);
				Context v18 = TrustManagerService.-$$Nest$fgetmContext(this.this$0);
				v18.sendBroadcastAsUser(v14, UserHandle.SYSTEM, "android.permission.TRUST_LISTENER", 0);
				Binder.restoreCallingIdentity(v2);
				return;
			}
		}
	}
}

and the following sink code:
['LockPatternUtils v3 = this.mLockPatternUtils;\nboolean v4 = v3.isSeparateProfileChallengeEnabled(p1);\nLockPatternUtils v5 = this.mLockPatternUtils;\nboolean v6 = v5.isSecure(p1);\nSparseBooleanArray v8 = this.mDeviceLockedForUser;\nv8.put(p1, p2);\nObject v12 = this.mContext.getSystemService(BiometricManage.class);\n[J v13 = v12.getAuthenticatorIds(p1);\nIKeystoreAuthorization v17 = IKeystoreAuthorization$Stub.asInterface(v16);\nv15.onLockScreenEvent(1, p1, 0, v10);\nIntent v21 = new Intent("android.intent.action.DEVICE_LOCKED_CHANGED");\nv21.putExtra("android.intent.extra.user_handle", p1);\nContext v25 = TrustManagerService.-$$Nest$fgetmContext(this.this$0);\nv25.sendBroadcastAsUser(v21, UserHandle.SYSTEM, "android.permission.TRUST_LISTENER", 0);']

The method setDeviceLockedForUser has the following similar APIs:

- API Name: detectFace(Landroid/os/IBinder;ILandroid/hardware/face/IFaceServiceReceiver;Ljava/lang/String;)J with Similarity Score: 0.7804129719734192
  - Access Control Level: SYS_OR_SIG and the following code:
LockPatternUtils v11 = this.mLockPatternUtils;
int v13 = v11.getStrongAuthForUser(p2);
ClientMonitorCallbackConverter v41 = new ClientMonitorCallbackConverter(p3);
long v43 = Pair.second.scheduleFaceDetect(v40, p1, p2, v41, p4, 1);
return v43;

- API Name: detectFace(Landroid/os/IBinder;ILandroid/hardware/face/IFaceServiceReceiver;Ljava/lang/String;)J with Similarity Score: 0.7727724313735962
  - Access Control Level: SYS_OR_SIG and the following code:
LockPatternUtils v5 = FaceService.-$$Nest$fgetmLockPatternUtils(this.this$0);
boolean v6 = Utils.isUserEncryptedOrLockdown(v5, p2);
ClientMonitorCallbackConverter v9 = new ClientMonitorCallbackConverter(p3);
long v11 = Pair.second.scheduleFaceDetect(v8, p1, p2, v9, p4, 1);
return v11;

