The method setDebugFlags has the following code snippet:

This is path 1 for the API with depth 0:
public void setDebugFlags(int p1, int p2){
	if ((p2 & 4) == 0) {
		boolean v2 = StorageManager.isFileEncryptedNativeOnly();
		if (v2 != 0) {
			boolean v3 = this.mLockPatternUtils.isCredentialRequiredToDecrypt(0);
			if (v3 != 0) {
				long v4 = Binder.clearCallingIdentity();
				if ((p1 & 4) == 0) {
					String v5 = Boolean.toString(1);
					SystemProperties.set("persist.sys.emulate_fbe", v5);
					Object v7 = this.mContext.getSystemService(PowerManage.class);
					v7.reboot(0);
					Binder.restoreCallingIdentity(v4);
					if ((p2 & 3) == 0) {
						if ((p1 & 1) == 0) {
							long v10 = Binder.clearCallingIdentity();
							SystemProperties.set("persist.sys.adoptable", "force_on");
							Message v12 = this.mHandler.obtainMessage(10);
							v12.sendToTarget();
							Binder.restoreCallingIdentity(v10);
							if ((p2 & 24) == 0) {
								if ((p2 & 32) == 0) {
									return;
								}
							}
						}
					}
				}
			}
		}
	}
}


This is path 2 for the API with depth 0:
public void setDebugFlags(int p1, int p2){
	if ((p2 & 4) == 0) {
		boolean v2 = StorageManager.isFileEncryptedNativeOnly();
		if (v2 != 0) {
			boolean v3 = this.mLockPatternUtils.isCredentialRequiredToDecrypt(0);
			if (v3 != 0) {
				long v4 = Binder.clearCallingIdentity();
				if ((p1 & 4) == 0) {
					String v5 = Boolean.toString(1);
					SystemProperties.set("persist.sys.emulate_fbe", v5);
					Object v7 = this.mContext.getSystemService(PowerManage.class);
					v7.reboot(0);
					Binder.restoreCallingIdentity(v4);
					if ((p2 & 3) == 0) {
						if ((p1 & 1) == 0) {
							if ((p1 & 2) == 0) {
								long v10 = Binder.clearCallingIdentity();
								SystemProperties.set("persist.sys.adoptable", "force_on");
								Message v12 = this.mHandler.obtainMessage(10);
								v12.sendToTarget();
								Binder.restoreCallingIdentity(v10);
								if ((p2 & 24) == 0) {
									if ((p2 & 32) == 0) {
										return;
									}
								}
							}
						}
					}
				}
			}
		}
	}
}


This is path 3 for the API with depth 0:
public void setDebugFlags(int p1, int p2){
	if ((p2 & 4) == 0) {
		boolean v2 = StorageManager.isFileEncryptedNativeOnly();
		if (v2 != 0) {
			boolean v3 = this.mLockPatternUtils.isCredentialRequiredToDecrypt(0);
			if (v3 != 0) {
				long v4 = Binder.clearCallingIdentity();
				if ((p1 & 4) == 0) {
					String v5 = Boolean.toString(1);
					SystemProperties.set("persist.sys.emulate_fbe", v5);
					Object v7 = this.mContext.getSystemService(PowerManage.class);
					v7.reboot(0);
					Binder.restoreCallingIdentity(v4);
					if ((p2 & 3) == 0) {
						if ((p2 & 24) == 0) {
							if ((p1 & 8) == 0) {
								long v10 = Binder.clearCallingIdentity();
								SystemProperties.set("persist.sys.sdcardfs", "force_on");
								Message v12 = this.mHandler.obtainMessage(10);
								v12.sendToTarget();
								Binder.restoreCallingIdentity(v10);
								if ((p2 & 32) == 0) {
									return;
								}
							}
						}
					}
				}
			}
		}
	}
}

and the following sink code:
['if ((p2 & 4) == 0) {\nboolean v2 = StorageManager.isFileEncryptedNativeOnly();\nif (v2 != 0) {\nboolean v3 = this.mLockPatternUtils.isCredentialRequiredToDecrypt(0);\nif (v3 != 0) {\nlong v4 = Binder.clearCallingIdentity();\nif ((p1 & 4) == 0) {\nString v5 = Boolean.toString(1);\nSystemProperties.set("persist.sys.emulate_fbe", v5);\nObject v7 = this.mContext.getSystemService(PowerManage.class);\nv7.reboot(0);\nBinder.restoreCallingIdentity(v4);', 'if ((p2 & 3) == 0) {\nif ((p1 & 1) == 0) {\nlong v10 = Binder.clearCallingIdentity();\nSystemProperties.set("persist.sys.adoptable", "force_on");\nMessage v12 = this.mHandler.obtainMessage(10);\nv12.sendToTarget();\nBinder.restoreCallingIdentity(v10);', 'if ((p2 & 24) == 0) {\nif ((p1 & 8) == 0) {\nlong v10 = Binder.clearCallingIdentity();\nSystemProperties.set("persist.sys.sdcardfs", "force_on");\nMessage v12 = this.mHandler.obtainMessage(10);\nv12.sendToTarget();\nBinder.restoreCallingIdentity(v10);']

The method setDebugFlags has the following similar APIs:

- API Name: getHashFactor(Lcom/android/internal/widget/LockscreenCredential;I)[B with Similarity Score: 0.7475215196609497
  - Access Control Level: DANGEROUS and the following code:
UserManager v4 = LockSettingsService.getUserManagerFromCache(p2);
boolean v5 = v4.isCredentialSharableWithParent();
byte[] v11 = LockSettingsStorage.readFile(v10);
Key v19 = this.mJavaKeyStore.getKey(v18, 0);
Cipher v20 = Cipher.getInstance("AES/GCM/NoPadding");
byte[] v24 = v20.doFinal(v13);

- API Name: setDeviceLockedForUser(IZ)V with Similarity Score: 0.7336164712905884
  - Access Control Level: SYS_OR_SIG and the following code:
LockPatternUtils v3 = this.mLockPatternUtils;
boolean v4 = v3.isSeparateProfileChallengeEnabled(p1);
LockPatternUtils v5 = this.mLockPatternUtils;
boolean v6 = v5.isSecure(p1);
SparseBooleanArray v8 = this.mDeviceLockedForUser;
v8.put(p1, p2);
Object v12 = this.mContext.getSystemService(BiometricManage.class);
[J v13 = v12.getAuthenticatorIds(p1);
IKeystoreAuthorization v17 = IKeystoreAuthorization$Stub.asInterface(v16);
v15.onLockScreenEvent(1, p1, 0, v10);
Intent v21 = new Intent("android.intent.action.DEVICE_LOCKED_CHANGED");
v21.putExtra("android.intent.extra.user_handle", p1);
Context v25 = TrustManagerService.-$$Nest$fgetmContext(this.this$0);
v25.sendBroadcastAsUser(v21, UserHandle.SYSTEM, "android.permission.TRUST_LISTENER", 0);

