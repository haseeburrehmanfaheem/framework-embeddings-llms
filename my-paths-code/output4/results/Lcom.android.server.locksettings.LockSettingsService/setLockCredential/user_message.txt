This is path 1 for the API with depth 2:
public boolean setLockCredential(LockscreenCredential p1, LockscreenCredential p2, int p3){
	Preconditions.checkState(phiInstruction, "Credential is already zeroized");
	int v1 = this.mType;
	boolean v4 = p0.hasPermission("android.permission.ACCESS_KEYGUARD_SECURE_STORAGE");
	boolean v5 = p0.hasPermission("android.permission.SET_AND_VERIFY_LOCKSCREEN_CREDENTIALS");
	boolean v6 = p0.hasPermission("android.permission.SET_INITIAL_LOCK");
	boolean v7 = p2.isNone();
	long v8 = Binder.clearCallingIdentity();
	ContentResolver v10 = this.mContext.getContentResolver();
	int v12 = Settings$Secure.getIntForUser(v10, "user_setup_complete", 0, 0);
	int v11 = v12;
	int v14 = Settings$Secure.getIntForUser(v10, "secure_frp_mode", 0, 0);
	int v13 = v14;
	boolean v15 = p2.isNone();
	UserManager v18 = LockSettingsService.getUserManagerFromCache(p1);
	boolean v19 = v18.isCredentialSharableWithParent();
	boolean v17 = v19;
	boolean v21 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
	boolean v20 = v21;
	boolean v16 = phiInstruction;
	UserInfo v22 = this.mUserManager.getProfileParent(p3);
	boolean v24 = phiInstruction;
	boolean v26 = phiInstruction;
	long v28 = Binder.clearCallingIdentity();
	boolean v30 = p1.isNone();
	ContentResolver v31 = this.mContext.getContentResolver();
	int v32 = this.mInjector.settingsGlobalGetInt(v31, "device_provisioned", 0);
	VerifyCredentialResponse v33 = LockSettingsService.spBasedDoVerifyCredential(p1, p2, 0, p3);
	LockSettingsStorage$CredentialHash v34 = this.mStorage.readCredentialHash(p2);
	boolean v35 = p1.checkAgainstStoredType(LockSettingsStorage$CredentialHash.type);
	int v41 = p1.getType();
	VerifyCredentialResponse v29 = VerifyCredentialResponse.ERROR;
	Binder.restoreCallingIdentity(v28);
	LockSettingsService$$ExternalSyntheticLambda3 v47 = new LockSettingsService$$ExternalSyntheticLambda3();
	boolean v49 = this.mHandler.postDelayed(v47, 2000);
	VerifyCredentialResponse v23 = v29;
	p2.zeroize();
	LockscreenCredential v51 = LockscreenCredential.createNone();
	Object v53 = Objects.requireNonNull(p1);
	Object v54 = Objects.requireNonNull(phiInstruction);
	LockSettingsStorage$PersistentData v56 = this.mStorage.readPersistentDataBlock();
	boolean v55 = phiInstruction;
	boolean v57 = p1.isNone();
	LockSettingsStorage$CredentialHash v59 = LockSettingsStorage.readPasswordHashIfExists(p3);
	LockSettingsStorage$CredentialHash v60 = LockSettingsStorage.readPatternHashIfExists(p3);
	LockSettingsStorage$CredentialHash v61 = LockSettingsStorage$CredentialHash.createEmptyHash();
	LockSettingsStorage$CredentialHash v58 = v61;
	boolean v63 = LockSettingsService.isCredentialSharableWithParent(p3);
	boolean v64 = LockSettingsService.getSeparateProfileChallengeEnabledInternal(p3);
	boolean v62 = phiInstruction;
	boolean v65 = phiInstruction.isNone();
	byte[] v67 = this.mStorage.readChildProfileLock(p3);
	byte[] v68 = Arrays.copyOfRange(v67, 0, 12);
	byte[] v69 = Arrays.copyOfRange(v67, 12, v67.length);
	StringBuilder v70 = new StringBuilder();
	StringBuilder v72 = v70.append("profile_key_name_decrypt_");
	StringBuilder v73 = v70.append(p3);
	String v74 = v70.toString();
	Key v75 = this.mJavaKeyStore.getKey(v74, 0);
	Cipher v76 = Cipher.getInstance("AES/GCM/NoPadding");
	GCMParameterSpec v77 = new GCMParameterSpec(128,v68);
	v76.init(2, v75, v77);
	byte[] v80 = v76.doFinal(v69);
	LockscreenCredential v81 = LockscreenCredential.createManagedPassword(v80);
	Arrays.fill(v80, 0);
	this.mManagedProfilePasswordCache.storePassword(p3, v81);
	LockscreenCredential v66 = v81;
	long v92 = LockSettingsService.getSyntheticPasswordHandleLocked(p3);
	Preconditions.checkState(phiInstruction, "Cannot reinitialize SP");
	IGateKeeperService v94 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationToken v95 = this.mSpManager.newSyntheticPasswordAndSid(v94, LockSettingsStorage$CredentialHash.hash, phiInstruction, p3);
	IGateKeeperService v96 = LockSettingsService.getGateKeeperService();
	long v97 = this.mSpManager.createPasswordBasedSyntheticPassword(v96, phiInstruction, v95, p3);
	boolean v98 = phiInstruction.isNone();
	IGateKeeperService v99 = LockSettingsService.getGateKeeperService();
	this.mSpManager.newSidForUser(v99, v95, p3);
	IGateKeeperService v101 = LockSettingsService.getGateKeeperService();
	VerifyCredentialResponse v102 = this.mSpManager.verifyChallenge(v101, v95, 0, p3);
	byte[] v103 = v95.deriveDiskEncryptionKey();
	LockSettingsService.setUserKeyProtection(p3, v103);
	byte[] v105 = v95.deriveKeyStorePassword();
	LockSettingsService.setKeystorePassword(v105, p3);
	LockSettingsService.fixateNewestUserKeyAuth(p3);
	LockSettingsService.setSyntheticPasswordHandleLocked(v97, p3);
	LockSettingsService.onAuthTokenKnownForUser(p3, v95);
	SyntheticPasswordManager$AuthenticationToken v85 = v95;
	boolean v111 = phiInstruction.isNone();
	boolean v112 = LockSettingsService.isProfileWithUnifiedLock(p3);
	LockscreenCredential v113 = LockSettingsService.getDecryptedPasswordForTiedProfile(p3);
	long v115 = LockSettingsService.getSyntheticPasswordHandleLocked(p3);
	IGateKeeperService v116 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v117 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v116, v115, phiInstruction, p3, 0);
	int v118 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	int v119 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	boolean v110 = 0;
	boolean v52 = v110;
	LockSettingsService.checkReadPermission("lockscreen.profilechallenge", p1);
	boolean v124 = "lock_pattern_autolock".equals("lockscreen.profilechallenge");
	int v125 = LockSettingsService.getCredentialTypeInternal(p1);
	boolean v122 = phiInstruction;
	LockSettingsService.checkWritePermission(p1);
	this.mStorage.setBoolean("lockscreen.profilechallenge", p2, p1);
	String v130 = LockSettingsStorage.getChildProfileLockFile(p1);
	LockSettingsStorage.deleteFile(v130);
	caughtException.printStackTrace();
	StringBuilder v140 = new StringBuilder();
	StringBuilder v142 = v140.append("profile_key_name_encrypt_");
	StringBuilder v143 = v140.append(p1);
	String v144 = v140.toString();
	this.mJavaKeyStore.deleteEntry(v144);
	StringBuilder v146 = new StringBuilder();
	StringBuilder v148 = v146.append("profile_key_name_decrypt_");
	StringBuilder v149 = v146.append(p1);
	String v150 = v146.toString();
	this.mJavaKeyStore.deleteEntry(v150);
	p0.notifyPasswordChanged(p1, p3);
	UserHandle v161 = UserHandle.of(p1);
	boolean v162 = this.mUserManagerCache.containsKey(v161);
	Context v163 = this.mContext.createPackageContextAsUser("system", 0, v161);
	Object v164 = v163.getSystemService(UserManage.class);
	Object v165 = this.mUserManagerCache.put(v161, v164);
	UserManager v160 = v164;
	boolean v166 = v160.isCredentialSharableWithParent();
	boolean v159 = v166;
	Object v168 = this.mContext.getSystemService(TrustManage.class);
	this.mService.setDeviceLockedForUser(p1, 0);
	p0.notifySeparateProfileChallengeChanged(p3);
	boolean v174 = StorageManager.isEncrypted();
	boolean v173 = v174;
	boolean v176 = LockSettingsService.isCredentialRequiredToDecrypt();
	boolean v177 = LockSettingsService.isDoNotAskCredentialsOnBootSet();
	boolean v175 = phiInstruction;
	boolean v178 = p1.isNone();
	boolean v180 = LockSettingsService.isDeviceEncryptionEnabled();
	ContentResolver v181 = this.mContext.getContentResolver();
	boolean v182 = Settings$Global.putInt(v181, "require_password_to_decrypt", 0);
	boolean v183 = p1.isPattern();
	LockSettingsService.checkWritePermission(p2);
	this.mStorage.setBoolean("lockscreen.patterneverchosen", 1, p2);
	boolean v188 = p1.isNone();
	boolean v189 = p1.isPattern();
	String v190 = LockSettingsService.getString("lockscreen.passwordhistory", 0, p2);
	int v191 = LockSettingsService.getRequestedPasswordHistoryLength(p2);
	byte[] v192 = LockSettingsService.getHashFactor(p1, p2);
	String v193 = LockSettingsService.getSalt(p2);
	byte[] v194 = v193.getBytes();
	String v195 = p1.passwordToHistoryHash(v194, v192);
	String v197 = p1.legacyPasswordToHash(v194);
	boolean v198 = TextUtils.isEmpty(phiInstruction);
	String v199 = phiInstruction.split(",");
	StringJoiner v200 = new StringJoiner(",");
	StringJoiner v202 = v200.add(phiInstruction);
	String v203 = v200.toString();
	LockSettingsService.setString("lockscreen.passwordhistory", phiInstruction, p2);
	Object v205 = this.mContext.getSystemService(TrustManage.class);
	this.mService.reportEnabledTrustAgentsChanged(p2);
	p0.scheduleGc();
	Binder.restoreCallingIdentity(v8);
	return 1;
}

This is path 2 for the API with depth 2:
public boolean setLockCredential(LockscreenCredential p1, LockscreenCredential p2, int p3){
	Preconditions.checkState(phiInstruction, "Credential is already zeroized");
	int v1 = this.mType;
	boolean v4 = p0.hasPermission("android.permission.ACCESS_KEYGUARD_SECURE_STORAGE");
	boolean v5 = p0.hasPermission("android.permission.SET_AND_VERIFY_LOCKSCREEN_CREDENTIALS");
	boolean v6 = p0.hasPermission("android.permission.SET_INITIAL_LOCK");
	boolean v7 = p2.isNone();
	long v8 = Binder.clearCallingIdentity();
	ContentResolver v10 = this.mContext.getContentResolver();
	int v12 = Settings$Secure.getIntForUser(v10, "user_setup_complete", 0, 0);
	int v11 = v12;
	int v14 = Settings$Secure.getIntForUser(v10, "secure_frp_mode", 0, 0);
	int v13 = v14;
	boolean v15 = p2.isNone();
	UserManager v18 = LockSettingsService.getUserManagerFromCache(p1);
	boolean v19 = v18.isCredentialSharableWithParent();
	boolean v17 = v19;
	boolean v21 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
	boolean v20 = v21;
	boolean v16 = phiInstruction;
	UserInfo v22 = this.mUserManager.getProfileParent(p3);
	boolean v24 = phiInstruction;
	boolean v26 = phiInstruction;
	long v28 = Binder.clearCallingIdentity();
	boolean v30 = p1.isNone();
	ContentResolver v31 = this.mContext.getContentResolver();
	int v32 = this.mInjector.settingsGlobalGetInt(v31, "device_provisioned", 0);
	VerifyCredentialResponse v33 = LockSettingsService.spBasedDoVerifyCredential(p1, p2, 0, p3);
	LockSettingsStorage$CredentialHash v34 = this.mStorage.readCredentialHash(p2);
	boolean v35 = p1.checkAgainstStoredType(LockSettingsStorage$CredentialHash.type);
	int v41 = p1.getType();
	VerifyCredentialResponse v29 = VerifyCredentialResponse.ERROR;
	Binder.restoreCallingIdentity(v28);
	LockSettingsService$$ExternalSyntheticLambda3 v47 = new LockSettingsService$$ExternalSyntheticLambda3();
	boolean v49 = this.mHandler.postDelayed(v47, 2000);
	VerifyCredentialResponse v23 = v29;
	p2.zeroize();
	LockscreenCredential v51 = LockscreenCredential.createNone();
	Object v53 = Objects.requireNonNull(p1);
	Object v54 = Objects.requireNonNull(phiInstruction);
	LockSettingsStorage$PersistentData v56 = this.mStorage.readPersistentDataBlock();
	boolean v55 = phiInstruction;
	boolean v57 = p1.isNone();
	LockSettingsStorage$CredentialHash v59 = LockSettingsStorage.readPasswordHashIfExists(p3);
	LockSettingsStorage$CredentialHash v60 = LockSettingsStorage.readPatternHashIfExists(p3);
	LockSettingsStorage$CredentialHash v61 = LockSettingsStorage$CredentialHash.createEmptyHash();
	LockSettingsStorage$CredentialHash v58 = v61;
	boolean v63 = LockSettingsService.isCredentialSharableWithParent(p3);
	boolean v64 = LockSettingsService.getSeparateProfileChallengeEnabledInternal(p3);
	boolean v62 = phiInstruction;
	boolean v65 = phiInstruction.isNone();
	byte[] v67 = this.mStorage.readChildProfileLock(p3);
	byte[] v68 = Arrays.copyOfRange(v67, 0, 12);
	byte[] v69 = Arrays.copyOfRange(v67, 12, v67.length);
	StringBuilder v70 = new StringBuilder();
	StringBuilder v72 = v70.append("profile_key_name_decrypt_");
	StringBuilder v73 = v70.append(p3);
	String v74 = v70.toString();
	Key v75 = this.mJavaKeyStore.getKey(v74, 0);
	Cipher v76 = Cipher.getInstance("AES/GCM/NoPadding");
	GCMParameterSpec v77 = new GCMParameterSpec(128,v68);
	v76.init(2, v75, v77);
	byte[] v80 = v76.doFinal(v69);
	LockscreenCredential v81 = LockscreenCredential.createManagedPassword(v80);
	Arrays.fill(v80, 0);
	this.mManagedProfilePasswordCache.storePassword(p3, v81);
	LockscreenCredential v66 = v81;
	long v92 = LockSettingsService.getSyntheticPasswordHandleLocked(p3);
	Preconditions.checkState(phiInstruction, "Cannot reinitialize SP");
	IGateKeeperService v94 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationToken v95 = this.mSpManager.newSyntheticPasswordAndSid(v94, LockSettingsStorage$CredentialHash.hash, phiInstruction, p3);
	IGateKeeperService v96 = LockSettingsService.getGateKeeperService();
	long v97 = this.mSpManager.createPasswordBasedSyntheticPassword(v96, phiInstruction, v95, p3);
	boolean v98 = phiInstruction.isNone();
	IGateKeeperService v99 = LockSettingsService.getGateKeeperService();
	this.mSpManager.newSidForUser(v99, v95, p3);
	IGateKeeperService v101 = LockSettingsService.getGateKeeperService();
	VerifyCredentialResponse v102 = this.mSpManager.verifyChallenge(v101, v95, 0, p3);
	byte[] v103 = v95.deriveDiskEncryptionKey();
	LockSettingsService.setUserKeyProtection(p3, v103);
	byte[] v105 = v95.deriveKeyStorePassword();
	LockSettingsService.setKeystorePassword(v105, p3);
	LockSettingsService.fixateNewestUserKeyAuth(p3);
	LockSettingsService.setSyntheticPasswordHandleLocked(v97, p3);
	LockSettingsService.onAuthTokenKnownForUser(p3, v95);
	SyntheticPasswordManager$AuthenticationToken v85 = v95;
	boolean v111 = phiInstruction.isNone();
	boolean v112 = LockSettingsService.isProfileWithUnifiedLock(p3);
	LockscreenCredential v113 = LockSettingsService.getDecryptedPasswordForTiedProfile(p3);
	long v115 = LockSettingsService.getSyntheticPasswordHandleLocked(p3);
	IGateKeeperService v116 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v117 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v116, v115, phiInstruction, p3, 0);
	int v118 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	int v119 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	boolean v110 = 0;
	boolean v52 = v110;
	LockSettingsService.checkReadPermission("lockscreen.profilechallenge", p1);
	boolean v124 = "lock_pattern_autolock".equals("lockscreen.profilechallenge");
	int v125 = LockSettingsService.getCredentialTypeInternal(p1);
	boolean v122 = phiInstruction;
	LockSettingsService.checkWritePermission(p1);
	this.mStorage.setBoolean("lockscreen.profilechallenge", p2, p1);
	String v130 = LockSettingsStorage.getChildProfileLockFile(p1);
	LockSettingsStorage.deleteFile(v130);
	caughtException.printStackTrace();
	StringBuilder v140 = new StringBuilder();
	StringBuilder v142 = v140.append("profile_key_name_encrypt_");
	StringBuilder v143 = v140.append(p1);
	String v144 = v140.toString();
	this.mJavaKeyStore.deleteEntry(v144);
	StringBuilder v146 = new StringBuilder();
	StringBuilder v148 = v146.append("profile_key_name_decrypt_");
	StringBuilder v149 = v146.append(p1);
	String v150 = v146.toString();
	this.mJavaKeyStore.deleteEntry(v150);
	p0.notifyPasswordChanged(p1, p3);
	UserHandle v161 = UserHandle.of(p1);
	boolean v162 = this.mUserManagerCache.containsKey(v161);
	Context v163 = this.mContext.createPackageContextAsUser("system", 0, v161);
	Object v164 = v163.getSystemService(UserManage.class);
	Object v165 = this.mUserManagerCache.put(v161, v164);
	UserManager v160 = v164;
	boolean v166 = v160.isCredentialSharableWithParent();
	boolean v159 = v166;
	Object v168 = this.mContext.getSystemService(TrustManage.class);
	this.mService.setDeviceLockedForUser(p1, 0);
	p0.notifySeparateProfileChallengeChanged(p3);
	boolean v174 = StorageManager.isEncrypted();
	boolean v173 = v174;
	boolean v176 = LockSettingsService.isCredentialRequiredToDecrypt();
	boolean v177 = LockSettingsService.isDoNotAskCredentialsOnBootSet();
	boolean v175 = phiInstruction;
	boolean v178 = p1.isNone();
	boolean v180 = LockSettingsService.isDeviceEncryptionEnabled();
	ContentResolver v181 = this.mContext.getContentResolver();
	boolean v182 = Settings$Global.putInt(v181, "require_password_to_decrypt", 0);
	boolean v183 = p1.isPattern();
	LockSettingsService.checkWritePermission(p2);
	this.mStorage.setBoolean("lockscreen.patterneverchosen", 1, p2);
	boolean v188 = p1.isNone();
	boolean v189 = p1.isPattern();
	String v190 = LockSettingsService.getString("lockscreen.passwordhistory", 0, p2);
	int v191 = LockSettingsService.getRequestedPasswordHistoryLength(p2);
	byte[] v192 = LockSettingsService.getHashFactor(p1, p2);
	String v193 = LockSettingsService.getSalt(p2);
	byte[] v194 = v193.getBytes();
	String v195 = p1.passwordToHistoryHash(v194, v192);
	String v197 = p1.legacyPasswordToHash(v194);
	boolean v198 = TextUtils.isEmpty(phiInstruction);
	String v199 = phiInstruction.split(",");
	StringJoiner v200 = new StringJoiner(",");
	StringJoiner v202 = v200.add(phiInstruction);
	String v203 = v200.toString();
	LockSettingsService.setString("lockscreen.passwordhistory", phiInstruction, p2);
	Object v205 = this.mContext.getSystemService(TrustManage.class);
	this.mService.reportEnabledTrustAgentsChanged(p2);
	p0.scheduleGc();
	Binder.restoreCallingIdentity(v8);
	return 1;
}

This is path 3 for the API with depth 2:
public boolean setLockCredential(LockscreenCredential p1, LockscreenCredential p2, int p3){
	Preconditions.checkState(phiInstruction, "Credential is already zeroized");
	int v1 = this.mType;
	boolean v4 = p0.hasPermission("android.permission.ACCESS_KEYGUARD_SECURE_STORAGE");
	boolean v5 = p0.hasPermission("android.permission.SET_AND_VERIFY_LOCKSCREEN_CREDENTIALS");
	boolean v6 = p0.hasPermission("android.permission.SET_INITIAL_LOCK");
	boolean v7 = p2.isNone();
	long v8 = Binder.clearCallingIdentity();
	ContentResolver v10 = this.mContext.getContentResolver();
	int v12 = Settings$Secure.getIntForUser(v10, "user_setup_complete", 0, 0);
	int v11 = v12;
	int v14 = Settings$Secure.getIntForUser(v10, "secure_frp_mode", 0, 0);
	int v13 = v14;
	boolean v15 = p2.isNone();
	UserManager v18 = LockSettingsService.getUserManagerFromCache(p1);
	boolean v19 = v18.isCredentialSharableWithParent();
	boolean v17 = v19;
	boolean v21 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
	boolean v20 = v21;
	boolean v16 = phiInstruction;
	UserInfo v22 = this.mUserManager.getProfileParent(p3);
	boolean v24 = phiInstruction;
	boolean v26 = phiInstruction;
	long v28 = Binder.clearCallingIdentity();
	boolean v30 = p1.isNone();
	ContentResolver v31 = this.mContext.getContentResolver();
	int v32 = this.mInjector.settingsGlobalGetInt(v31, "device_provisioned", 0);
	VerifyCredentialResponse v33 = LockSettingsService.spBasedDoVerifyCredential(p1, p2, 0, p3);
	LockSettingsStorage$CredentialHash v34 = this.mStorage.readCredentialHash(p2);
	boolean v35 = p1.checkAgainstStoredType(LockSettingsStorage$CredentialHash.type);
	int v41 = p1.getType();
	VerifyCredentialResponse v29 = VerifyCredentialResponse.ERROR;
	Binder.restoreCallingIdentity(v28);
	LockSettingsService$$ExternalSyntheticLambda3 v47 = new LockSettingsService$$ExternalSyntheticLambda3();
	boolean v49 = this.mHandler.postDelayed(v47, 2000);
	VerifyCredentialResponse v23 = v29;
	p2.zeroize();
	LockscreenCredential v51 = LockscreenCredential.createNone();
	Object v53 = Objects.requireNonNull(p1);
	Object v54 = Objects.requireNonNull(phiInstruction);
	LockSettingsStorage$PersistentData v56 = this.mStorage.readPersistentDataBlock();
	boolean v55 = phiInstruction;
	boolean v57 = p1.isNone();
	LockSettingsStorage$CredentialHash v59 = LockSettingsStorage.readPasswordHashIfExists(p3);
	LockSettingsStorage$CredentialHash v60 = LockSettingsStorage.readPatternHashIfExists(p3);
	LockSettingsStorage$CredentialHash v61 = LockSettingsStorage$CredentialHash.createEmptyHash();
	LockSettingsStorage$CredentialHash v58 = v61;
	boolean v63 = LockSettingsService.isCredentialSharableWithParent(p3);
	boolean v64 = LockSettingsService.getSeparateProfileChallengeEnabledInternal(p3);
	boolean v62 = phiInstruction;
	boolean v65 = phiInstruction.isNone();
	byte[] v67 = this.mStorage.readChildProfileLock(p3);
	byte[] v68 = Arrays.copyOfRange(v67, 0, 12);
	byte[] v69 = Arrays.copyOfRange(v67, 12, v67.length);
	StringBuilder v70 = new StringBuilder();
	StringBuilder v72 = v70.append("profile_key_name_decrypt_");
	StringBuilder v73 = v70.append(p3);
	String v74 = v70.toString();
	Key v75 = this.mJavaKeyStore.getKey(v74, 0);
	Cipher v76 = Cipher.getInstance("AES/GCM/NoPadding");
	GCMParameterSpec v77 = new GCMParameterSpec(128,v68);
	v76.init(2, v75, v77);
	byte[] v80 = v76.doFinal(v69);
	LockscreenCredential v81 = LockscreenCredential.createManagedPassword(v80);
	Arrays.fill(v80, 0);
	this.mManagedProfilePasswordCache.storePassword(p3, v81);
	LockscreenCredential v66 = v81;
	long v92 = LockSettingsService.getSyntheticPasswordHandleLocked(p3);
	Preconditions.checkState(phiInstruction, "Cannot reinitialize SP");
	IGateKeeperService v94 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationToken v95 = this.mSpManager.newSyntheticPasswordAndSid(v94, LockSettingsStorage$CredentialHash.hash, phiInstruction, p3);
	IGateKeeperService v96 = LockSettingsService.getGateKeeperService();
	long v97 = this.mSpManager.createPasswordBasedSyntheticPassword(v96, phiInstruction, v95, p3);
	boolean v98 = phiInstruction.isNone();
	IGateKeeperService v99 = LockSettingsService.getGateKeeperService();
	this.mSpManager.newSidForUser(v99, v95, p3);
	IGateKeeperService v101 = LockSettingsService.getGateKeeperService();
	VerifyCredentialResponse v102 = this.mSpManager.verifyChallenge(v101, v95, 0, p3);
	byte[] v103 = v95.deriveDiskEncryptionKey();
	LockSettingsService.setUserKeyProtection(p3, v103);
	byte[] v105 = v95.deriveKeyStorePassword();
	LockSettingsService.setKeystorePassword(v105, p3);
	LockSettingsService.fixateNewestUserKeyAuth(p3);
	LockSettingsService.setSyntheticPasswordHandleLocked(v97, p3);
	LockSettingsService.onAuthTokenKnownForUser(p3, v95);
	SyntheticPasswordManager$AuthenticationToken v85 = v95;
	boolean v111 = phiInstruction.isNone();
	boolean v112 = LockSettingsService.isProfileWithUnifiedLock(p3);
	LockscreenCredential v113 = LockSettingsService.getDecryptedPasswordForTiedProfile(p3);
	long v115 = LockSettingsService.getSyntheticPasswordHandleLocked(p3);
	IGateKeeperService v116 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v117 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v116, v115, phiInstruction, p3, 0);
	int v118 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	int v119 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	boolean v110 = 0;
	boolean v52 = v110;
	LockSettingsService.checkReadPermission("lockscreen.profilechallenge", p1);
	boolean v124 = "lock_pattern_autolock".equals("lockscreen.profilechallenge");
	int v125 = LockSettingsService.getCredentialTypeInternal(p1);
	boolean v122 = phiInstruction;
	LockSettingsService.checkWritePermission(p1);
	this.mStorage.setBoolean("lockscreen.profilechallenge", p2, p1);
	String v130 = LockSettingsStorage.getChildProfileLockFile(p1);
	LockSettingsStorage.deleteFile(v130);
	caughtException.printStackTrace();
	StringBuilder v140 = new StringBuilder();
	StringBuilder v142 = v140.append("profile_key_name_encrypt_");
	StringBuilder v143 = v140.append(p1);
	String v144 = v140.toString();
	this.mJavaKeyStore.deleteEntry(v144);
	StringBuilder v146 = new StringBuilder();
	StringBuilder v148 = v146.append("profile_key_name_decrypt_");
	StringBuilder v149 = v146.append(p1);
	String v150 = v146.toString();
	this.mJavaKeyStore.deleteEntry(v150);
	p0.notifyPasswordChanged(p1, p3);
	UserHandle v161 = UserHandle.of(p1);
	boolean v162 = this.mUserManagerCache.containsKey(v161);
	Context v163 = this.mContext.createPackageContextAsUser("system", 0, v161);
	Object v164 = v163.getSystemService(UserManage.class);
	Object v165 = this.mUserManagerCache.put(v161, v164);
	UserManager v160 = v164;
	boolean v166 = v160.isCredentialSharableWithParent();
	boolean v159 = v166;
	Object v168 = this.mContext.getSystemService(TrustManage.class);
	this.mService.setDeviceLockedForUser(p1, 0);
	p0.notifySeparateProfileChallengeChanged(p3);
	boolean v174 = StorageManager.isEncrypted();
	boolean v173 = v174;
	boolean v176 = LockSettingsService.isCredentialRequiredToDecrypt();
	boolean v177 = LockSettingsService.isDoNotAskCredentialsOnBootSet();
	boolean v175 = phiInstruction;
	boolean v178 = p1.isNone();
	boolean v180 = LockSettingsService.isDeviceEncryptionEnabled();
	ContentResolver v181 = this.mContext.getContentResolver();
	boolean v182 = Settings$Global.putInt(v181, "require_password_to_decrypt", 0);
	boolean v183 = p1.isPattern();
	LockSettingsService.checkWritePermission(p2);
	this.mStorage.setBoolean("lockscreen.patterneverchosen", 1, p2);
	boolean v188 = p1.isNone();
	boolean v189 = p1.isPattern();
	String v190 = LockSettingsService.getString("lockscreen.passwordhistory", 0, p2);
	int v191 = LockSettingsService.getRequestedPasswordHistoryLength(p2);
	byte[] v192 = LockSettingsService.getHashFactor(p1, p2);
	String v193 = LockSettingsService.getSalt(p2);
	byte[] v194 = v193.getBytes();
	String v195 = p1.passwordToHistoryHash(v194, v192);
	String v197 = p1.legacyPasswordToHash(v194);
	boolean v198 = TextUtils.isEmpty(phiInstruction);
	String v199 = phiInstruction.split(",");
	StringJoiner v200 = new StringJoiner(",");
	StringJoiner v202 = v200.add(phiInstruction);
	String v203 = v200.toString();
	LockSettingsService.setString("lockscreen.passwordhistory", phiInstruction, p2);
	Object v205 = this.mContext.getSystemService(TrustManage.class);
	this.mService.reportEnabledTrustAgentsChanged(p2);
	p0.scheduleGc();
	Binder.restoreCallingIdentity(v8);
	return 1;
}
