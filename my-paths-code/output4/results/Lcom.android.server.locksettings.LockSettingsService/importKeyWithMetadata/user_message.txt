This is path 1 for the API with depth 2:
public String importKeyWithMetadata(String p1, byte[] p2, byte[] p3){
	int v11 = UserHandle.getCallingUserId();
	int v12 = Binder.getCallingUid();
	this.mCleanupManager.registerRecoveryAgent(v11, v12);
	Object v14 = Objects.requireNonNull(p1, "alias is null");
	Object v15 = Objects.requireNonNull(p2, "keyBytes is null");
	int v16 = Binder.getCallingUid();
	int v17 = UserHandle.getCallingUserId();
	PlatformKeyManager.init(v17);
	PlatformDecryptionKey v20 = PlatformKeyManager.getDecryptKeyInternal(v17);
	Object v21 = new Object(1);
	Integer v22 = Integer.valueOf(v17);
	String v23 = String.format(Locale.US, "Regenerating permanently invalid Platform key for user %d.", v21);
	int v24 = Log.i("PlatformKeyManager", v23);
	PlatformKeyManager.regenerate(v17);
	PlatformEncryptionKey v26 = PlatformKeyManager.getEncryptKeyInternal(v17);
	PlatformEncryptionKey v18 = v26;
	SecretKeySpec v28 = new SecretKeySpec(p2,"AES");
	WrappedKey v30 = WrappedKey.fromSecretKey(v18, v28, p3);
	long v31 = this.mDatabase.insertKey(v17, v16, p1, v30);
	long v32 = this.mDatabase.setShouldCreateSnapshot(v17, v16, 1);
	Object v34 = new Object(4);
	Integer v35 = Integer.valueOf(v17);
	Integer v36 = Integer.valueOf(v16);
	Integer v37 = Integer.valueOf(p2.length);
	String v38 = String.format(Locale.US, "Set %d/%d/%s: %d bytes of key material", v34);
	int v39 = Log.i("RecoverableAppKeyStore", v38);
	String v40 = ApplicationKeyStorage.getInternalAlias(v17, v16, p1);
	KeyStore$SecretKeyEntry v41 = new KeyStore$SecretKeyEntry(v42);
	SecretKeySpec v42 = new SecretKeySpec(p2,"AES");
	KeyProtection$Builder v45 = new KeyProtection$Builder(3);
	String v47 = new String(1);
	KeyProtection$Builder v48 = v45.setBlockModes(v47);
	String v49 = new String(1);
	KeyProtection$Builder v50 = v48.setEncryptionPaddings(v49);
	KeyProtection v51 = v50.build();
	this.mKeyStore.setEntry(v40, v41, v51);
	String v54 = this.mApplicationKeyStorage.getGrantAlias(v17, v16, p1);
	String v53 = v54;
	String v1 = v53;
	return v1;
}

This is path 2 for the API with depth 2:
public String importKeyWithMetadata(String p1, byte[] p2, byte[] p3){
	int v11 = UserHandle.getCallingUserId();
	int v12 = Binder.getCallingUid();
	this.mCleanupManager.registerRecoveryAgent(v11, v12);
	Object v14 = Objects.requireNonNull(p1, "alias is null");
	Object v15 = Objects.requireNonNull(p2, "keyBytes is null");
	int v16 = Binder.getCallingUid();
	int v17 = UserHandle.getCallingUserId();
	PlatformKeyManager.init(v17);
	PlatformDecryptionKey v20 = PlatformKeyManager.getDecryptKeyInternal(v17);
	PlatformEncryptionKey v21 = PlatformKeyManager.getEncryptKeyInternal(v17);
	Object v22 = new Object(1);
	Integer v23 = Integer.valueOf(v17);
	String v24 = String.format(Locale.US, "Regenerating permanently invalid Platform key for user %d.", v22);
	int v25 = Log.i("PlatformKeyManager", v24);
	PlatformKeyManager.regenerate(v17);
	PlatformEncryptionKey v27 = PlatformKeyManager.getEncryptKeyInternal(v17);
	PlatformEncryptionKey v18 = v27;
	SecretKeySpec v29 = new SecretKeySpec(p2,"AES");
	WrappedKey v31 = WrappedKey.fromSecretKey(v18, v29, p3);
	long v32 = this.mDatabase.insertKey(v17, v16, p1, v31);
	long v33 = this.mDatabase.setShouldCreateSnapshot(v17, v16, 1);
	Object v35 = new Object(4);
	Integer v36 = Integer.valueOf(v17);
	Integer v37 = Integer.valueOf(v16);
	Integer v38 = Integer.valueOf(p2.length);
	String v39 = String.format(Locale.US, "Set %d/%d/%s: %d bytes of key material", v35);
	int v40 = Log.i("RecoverableAppKeyStore", v39);
	String v41 = ApplicationKeyStorage.getInternalAlias(v17, v16, p1);
	KeyStore$SecretKeyEntry v42 = new KeyStore$SecretKeyEntry(v43);
	SecretKeySpec v43 = new SecretKeySpec(p2,"AES");
	KeyProtection$Builder v46 = new KeyProtection$Builder(3);
	String v48 = new String(1);
	KeyProtection$Builder v49 = v46.setBlockModes(v48);
	String v50 = new String(1);
	KeyProtection$Builder v51 = v49.setEncryptionPaddings(v50);
	KeyProtection v52 = v51.build();
	this.mKeyStore.setEntry(v41, v42, v52);
	String v55 = this.mApplicationKeyStorage.getGrantAlias(v17, v16, p1);
	String v54 = v55;
	String v1 = v54;
	return v1;
}

This is path 3 for the API with depth 2:
public String importKeyWithMetadata(String p1, byte[] p2, byte[] p3){
	int v11 = UserHandle.getCallingUserId();
	int v12 = Binder.getCallingUid();
	this.mCleanupManager.registerRecoveryAgent(v11, v12);
	Object v14 = Objects.requireNonNull(p1, "alias is null");
	Object v15 = Objects.requireNonNull(p2, "keyBytes is null");
	int v16 = Binder.getCallingUid();
	int v17 = UserHandle.getCallingUserId();
	PlatformKeyManager.init(v17);
	PlatformDecryptionKey v20 = PlatformKeyManager.getDecryptKeyInternal(v17);
	PlatformEncryptionKey v21 = PlatformKeyManager.getEncryptKeyInternal(v17);
	PlatformEncryptionKey v18 = v21;
	SecretKeySpec v23 = new SecretKeySpec(p2,"AES");
	WrappedKey v25 = WrappedKey.fromSecretKey(v18, v23, p3);
	long v26 = this.mDatabase.insertKey(v17, v16, p1, v25);
	long v27 = this.mDatabase.setShouldCreateSnapshot(v17, v16, 1);
	Object v29 = new Object(4);
	Integer v30 = Integer.valueOf(v17);
	Integer v31 = Integer.valueOf(v16);
	Integer v32 = Integer.valueOf(p2.length);
	String v33 = String.format(Locale.US, "Set %d/%d/%s: %d bytes of key material", v29);
	int v34 = Log.i("RecoverableAppKeyStore", v33);
	String v35 = ApplicationKeyStorage.getInternalAlias(v17, v16, p1);
	KeyStore$SecretKeyEntry v36 = new KeyStore$SecretKeyEntry(v37);
	SecretKeySpec v37 = new SecretKeySpec(p2,"AES");
	KeyProtection$Builder v40 = new KeyProtection$Builder(3);
	String v42 = new String(1);
	KeyProtection$Builder v43 = v40.setBlockModes(v42);
	String v44 = new String(1);
	KeyProtection$Builder v45 = v43.setEncryptionPaddings(v44);
	KeyProtection v46 = v45.build();
	this.mKeyStore.setEntry(v35, v36, v46);
	String v49 = this.mApplicationKeyStorage.getGrantAlias(v17, v16, p1);
	String v48 = v49;
	String v1 = v48;
	return v1;
}
