This is path 1 for the API with depth 2:
public byte[] getHashFactor(LockscreenCredential p1, int p2){
	UserManager v5 = LockSettingsService.getUserManagerFromCache(p1);
	boolean v6 = v5.isCredentialSharableWithParent();
	boolean v4 = v6;
	boolean v8 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
	boolean v7 = v8;
	boolean v3 = phiInstruction;
	String v11 = LockSettingsStorage.getChildProfileLockFile(p1);
	byte[] v12 = LockSettingsStorage.readFile(v11);
	byte[] v10 = v12;
	byte[] v13 = Arrays.copyOfRange(v10, 0, 12);
	byte[] v14 = Arrays.copyOfRange(v10, 12, v10.length);
	StringBuilder v15 = new StringBuilder();
	StringBuilder v17 = v15.append("profile_key_name_decrypt_");
	StringBuilder v18 = v15.append(p2);
	String v19 = v15.toString();
	Key v20 = this.mJavaKeyStore.getKey(v19, 0);
	Cipher v21 = Cipher.getInstance("AES/GCM/NoPadding");
	GCMParameterSpec v22 = new GCMParameterSpec(128,v13);
	v21.init(2, v20, v22);
	byte[] v25 = v21.doFinal(v14);
	LockscreenCredential v27 = new LockscreenCredential(4,v28);
	byte[] v28 = Arrays.copyOf(v25, v25.length);
	LockscreenCredential v26 = v27;
	Arrays.fill(v25, 0);
	boolean v32 = this.mEncryptedPasswords.contains(p1);
	UserInfo v33 = this.mUserManager.getProfileParent(p1);
	String v34 = ManagedProfilePasswordCache.getEncryptionKeyName(p1);
	Provider v35 = this.mKeyStore.getProvider();
	KeyGenerator v36 = KeyGenerator.getInstance("AES", v35);
	KeyGenParameterSpec$Builder v37 = new KeyGenParameterSpec$Builder(v34,3);
	KeyGenParameterSpec$Builder v39 = v37.setKeySize(256);
	String v40 = new String(1);
	KeyGenParameterSpec$Builder v41 = v39.setBlockModes(v40);
	int v42 = SyntheticPasswordCrypto.keyNamespace();
	KeyGenParameterSpec$Builder v43 = v41.setNamespace(v42);
	String v44 = new String(1);
	KeyGenParameterSpec$Builder v45 = v43.setEncryptionPaddings(v44);
	KeyGenParameterSpec$Builder v46 = v45.setUserAuthenticationRequired(1);
	KeyGenParameterSpec$Builder v47 = v46.setUserAuthenticationValidityDurationSeconds(this.CACHE_TIMEOUT_SECONDS);
	KeyGenParameterSpec v48 = v47.build();
	v36.init(v48);
	SecretKey v50 = v36.generateKey();
	Cipher v51 = Cipher.getInstance("AES/GCM/NoPadding");
	LockscreenCredential v9 = v26;
	PersistentDataBlockManagerInternal v55 = LockSettingsStorage.getPersistentDataBlockManager();
	byte[] v56 = v55.getFrpCredentialHandle();
	LockSettingsStorage$PersistentData v57 = LockSettingsStorage$PersistentData.fromBytes(v56);
	LockSettingsStorage$PersistentData v54 = LockSettingsStorage$PersistentData.NONE;
	boolean v53 = phiInstruction;
	LockSettingsService.checkReadPermission("sp-handle", p1);
	long v62 = this.mStorage.getLong("sp-handle", 0, p1);
	long v60 = v62;
	long v59 = v60;
	IBinder v64 = ServiceManager.getService("android.service.gatekeeper.IGateKeeperService");
	LockSettingsService$GateKeeperDiedRecipient v65 = new LockSettingsService$GateKeeperDiedRecipient(LockSettingsService,0);
	v64.linkToDeath(v65, 0);
	IInterface v70 = v64.queryLocalInterface("android.service.gatekeeper.IGateKeeperService");
	IGateKeeperService$Stub$Proxy v71 = new IGateKeeperService$Stub$Proxy(v64);
	IGateKeeperService v69 = v71;
	this.mGateKeeperService = v69;
	IGateKeeperService v63 = v69;
	SyntheticPasswordManager$AuthenticationResult v74 = new SyntheticPasswordManager$AuthenticationResult();
	byte[] v77 = this.mStorage.readSyntheticPasswordState(p4, p2, "pwd");
	byte[] v76 = v77;
	SyntheticPasswordManager$PasswordData v79 = new SyntheticPasswordManager$PasswordData();
	ByteBuffer v81 = ByteBuffer.allocate(v76.length);
	ByteBuffer v82 = v81.put(v76, 0, v76.length);
	Buffer v83 = v81.flip();
	int v84 = v81.getInt();
	this.credentialType = v84;
	byte v85 = v81.get();
	this.scryptN = v85;
	byte v86 = v81.get();
	this.scryptR = v86;
	byte v87 = v81.get();
	this.scryptP = v87;
	int v88 = v81.getInt();
	[B v89 = new [B(v88);
	this.salt = v89;
	ByteBuffer v90 = v81.get(v89);
	int v91 = v81.getInt();
	[B v92 = new [B(v91);
	this.passwordHandle = v92;
	ByteBuffer v93 = v81.get(v92);
	SyntheticPasswordManager$PasswordData v78 = v79;
	int v95 = LockscreenCredential.getType();
	int v96 = LockscreenCredential.getType();
	boolean v94 = phiInstruction;
	boolean v98 = p3.isNone();
	byte[] v99 = SyntheticPasswordManager.scrypt(phiInstruction, SyntheticPasswordManager$PasswordData.salt, (1 << SyntheticPasswordManager$PasswordData.scryptN), (1 << SyntheticPasswordManager$PasswordData.scryptR), (1 << SyntheticPasswordManager$PasswordData.scryptP), 32);
	byte[] v97 = v99;
	byte[] v101 = SyntheticPasswordManager.loadState("weaver", p2, p4);
	ByteBuffer v102 = ByteBuffer.allocate(5);
	ByteBuffer v103 = v102.put(v101, 0, v101.length);
	Buffer v104 = v102.flip();
	byte v105 = v102.get();
	int v100 = -1;
	boolean v112 = SyntheticPasswordManager.isWeaverAvailable();
	byte[] v113 = SyntheticPasswordManager.passwordTokenToWeaverKey(v97);
	[B v115 = new [B(WeaverConfig.keySize);
	VerifyCredentialResponse v116 = new VerifyCredentialResponse(1);
	ArrayList v117 = SyntheticPasswordManager.toByteArrayList(phiInstruction);
	SyntheticPasswordManager$$ExternalSyntheticLambda1 v118 = new SyntheticPasswordManager$$ExternalSyntheticLambda1(v116,v100);
	this.mWeaver.read(v100, v117, v118);
	VerifyCredentialResponse v114 = v116[0];
	SyntheticPasswordManager$AuthenticationResult.gkResponse = v114;
	int v127 = this.mResponseCode;
	byte[] v128 = this.mGatekeeperHAT;
	[[B v130 = new [[B(1);
	byte[] v131 = SyntheticPasswordCrypto.personalisedHash(this.PERSONALISATION_WEAVER_PASSWORD, v130);
	[B v132 = new [B((v97.length + v131.length));
	System.arraycopy(v97, 0, v132, 0, v97.length);
	System.arraycopy(v131, 0, v132, v97.length, v131.length);
	byte[] v129 = v132;
	0.onCredentialVerified();
	byte[] v138 = SyntheticPasswordManager.loadState("spblob", p2, p4);
	SyntheticPasswordManager$SyntheticPasswordBlob v139 = SyntheticPasswordManager$SyntheticPasswordBlob.fromBytes(v138);
	String v140 = SyntheticPasswordManager.getKeyName(p2);
	byte[] v141 = SyntheticPasswordCrypto.decryptBlobV1(v140, SyntheticPasswordManager$SyntheticPasswordBlob.mContent, phiInstruction);
	SyntheticPasswordManager$AuthenticationToken v142 = new SyntheticPasswordManager$AuthenticationToken(SyntheticPasswordManager$SyntheticPasswordBlob.mVersion);
	boolean v144 = SyntheticPasswordManager.loadEscrowData(v142, p4);
	v142.recreateFromEscrow(phiInstruction);
	SyntheticPasswordManager.createSyntheticPasswordBlob(p2, 0, v142, phiInstruction, phiInstruction, p4);
	SyntheticPasswordManager$AuthenticationToken v137 = v142;
	SyntheticPasswordManager$AuthenticationResult.authToken = v137;
	byte[] v156 = v137.deriveGkPassword();
	VerifyCredentialResponse v157 = SyntheticPasswordManager.verifyChallengeInternal(p1, v156, 0, p4);
	VerifyCredentialResponse v155 = v157;
	SyntheticPasswordManager$AuthenticationResult.gkResponse = v155;
	boolean v159 = SyntheticPasswordManager.hasState("metrics", p2, p4);
	boolean v158 = v159;
	byte[] v161 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveMetricsKey();
	[B v162 = new [B(0);
	VersionedPasswordMetrics v163 = new VersionedPasswordMetrics(p3);
	byte[] v165 = v163.serialize();
	byte[] v166 = SyntheticPasswordCrypto.encrypt(v161, v162, v165);
	SyntheticPasswordManager.saveState("metrics", v166, p2, p4);
	SyntheticPasswordManager$AuthenticationResult v73 = v74;
	byte[] v169 = this.PERSONALIZATION_PASSWORD_HASH;
	SP800Derive v171 = new SP800Derive(this.mSyntheticPassword);
	byte[] v173 = SyntheticPasswordManager.-$$Nest$sfgetPERSONALISATION_CONTEXT();
	byte[] v174 = v171.withContext(v169, v173);
	byte[] v170 = v174;
	byte[] v168 = v170;
	p0.scheduleGc();
	return v168;
}

This is path 2 for the API with depth 2:
public byte[] getHashFactor(LockscreenCredential p1, int p2){
	UserManager v5 = LockSettingsService.getUserManagerFromCache(p1);
	boolean v6 = v5.isCredentialSharableWithParent();
	boolean v4 = v6;
	boolean v8 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
	boolean v7 = v8;
	boolean v3 = phiInstruction;
	String v11 = LockSettingsStorage.getChildProfileLockFile(p1);
	byte[] v12 = LockSettingsStorage.readFile(v11);
	byte[] v10 = v12;
	byte[] v13 = Arrays.copyOfRange(v10, 0, 12);
	byte[] v14 = Arrays.copyOfRange(v10, 12, v10.length);
	StringBuilder v15 = new StringBuilder();
	StringBuilder v17 = v15.append("profile_key_name_decrypt_");
	StringBuilder v18 = v15.append(p2);
	String v19 = v15.toString();
	Key v20 = this.mJavaKeyStore.getKey(v19, 0);
	Cipher v21 = Cipher.getInstance("AES/GCM/NoPadding");
	GCMParameterSpec v22 = new GCMParameterSpec(128,v13);
	v21.init(2, v20, v22);
	byte[] v25 = v21.doFinal(v14);
	LockscreenCredential v27 = new LockscreenCredential(4,v28);
	byte[] v28 = Arrays.copyOf(v25, v25.length);
	LockscreenCredential v26 = v27;
	Arrays.fill(v25, 0);
	boolean v32 = this.mEncryptedPasswords.contains(p1);
	UserInfo v33 = this.mUserManager.getProfileParent(p1);
	String v34 = ManagedProfilePasswordCache.getEncryptionKeyName(p1);
	Provider v35 = this.mKeyStore.getProvider();
	KeyGenerator v36 = KeyGenerator.getInstance("AES", v35);
	KeyGenParameterSpec$Builder v37 = new KeyGenParameterSpec$Builder(v34,3);
	KeyGenParameterSpec$Builder v39 = v37.setKeySize(256);
	String v40 = new String(1);
	KeyGenParameterSpec$Builder v41 = v39.setBlockModes(v40);
	int v42 = SyntheticPasswordCrypto.keyNamespace();
	KeyGenParameterSpec$Builder v43 = v41.setNamespace(v42);
	String v44 = new String(1);
	KeyGenParameterSpec$Builder v45 = v43.setEncryptionPaddings(v44);
	KeyGenParameterSpec$Builder v46 = v45.setUserAuthenticationRequired(1);
	KeyGenParameterSpec$Builder v47 = v46.setUserAuthenticationValidityDurationSeconds(this.CACHE_TIMEOUT_SECONDS);
	KeyGenParameterSpec v48 = v47.build();
	v36.init(v48);
	SecretKey v50 = v36.generateKey();
	Cipher v51 = Cipher.getInstance("AES/GCM/NoPadding");
	LockscreenCredential v9 = v26;
	PersistentDataBlockManagerInternal v55 = LockSettingsStorage.getPersistentDataBlockManager();
	byte[] v56 = v55.getFrpCredentialHandle();
	LockSettingsStorage$PersistentData v57 = LockSettingsStorage$PersistentData.fromBytes(v56);
	LockSettingsStorage$PersistentData v54 = LockSettingsStorage$PersistentData.NONE;
	boolean v53 = phiInstruction;
	LockSettingsService.checkReadPermission("sp-handle", p1);
	long v62 = this.mStorage.getLong("sp-handle", 0, p1);
	long v60 = v62;
	long v59 = v60;
	IBinder v64 = ServiceManager.getService("android.service.gatekeeper.IGateKeeperService");
	LockSettingsService$GateKeeperDiedRecipient v65 = new LockSettingsService$GateKeeperDiedRecipient(LockSettingsService,0);
	v64.linkToDeath(v65, 0);
	IInterface v70 = v64.queryLocalInterface("android.service.gatekeeper.IGateKeeperService");
	IGateKeeperService$Stub$Proxy v71 = new IGateKeeperService$Stub$Proxy(v64);
	IGateKeeperService v69 = v71;
	this.mGateKeeperService = v69;
	IGateKeeperService v63 = v69;
	SyntheticPasswordManager$AuthenticationResult v74 = new SyntheticPasswordManager$AuthenticationResult();
	byte[] v77 = this.mStorage.readSyntheticPasswordState(p4, p2, "pwd");
	byte[] v76 = v77;
	SyntheticPasswordManager$PasswordData v79 = new SyntheticPasswordManager$PasswordData();
	ByteBuffer v81 = ByteBuffer.allocate(v76.length);
	ByteBuffer v82 = v81.put(v76, 0, v76.length);
	Buffer v83 = v81.flip();
	int v84 = v81.getInt();
	this.credentialType = v84;
	byte v85 = v81.get();
	this.scryptN = v85;
	byte v86 = v81.get();
	this.scryptR = v86;
	byte v87 = v81.get();
	this.scryptP = v87;
	int v88 = v81.getInt();
	[B v89 = new [B(v88);
	this.salt = v89;
	ByteBuffer v90 = v81.get(v89);
	int v91 = v81.getInt();
	[B v92 = new [B(v91);
	this.passwordHandle = v92;
	ByteBuffer v93 = v81.get(v92);
	SyntheticPasswordManager$PasswordData v78 = v79;
	int v95 = LockscreenCredential.getType();
	int v96 = LockscreenCredential.getType();
	boolean v94 = phiInstruction;
	boolean v98 = p3.isNone();
	byte[] v99 = SyntheticPasswordManager.scrypt(phiInstruction, SyntheticPasswordManager$PasswordData.salt, (1 << SyntheticPasswordManager$PasswordData.scryptN), (1 << SyntheticPasswordManager$PasswordData.scryptR), (1 << SyntheticPasswordManager$PasswordData.scryptP), 32);
	byte[] v97 = v99;
	byte[] v101 = SyntheticPasswordManager.loadState("weaver", p2, p4);
	ByteBuffer v102 = ByteBuffer.allocate(5);
	ByteBuffer v103 = v102.put(v101, 0, v101.length);
	Buffer v104 = v102.flip();
	byte v105 = v102.get();
	int v100 = -1;
	boolean v112 = SyntheticPasswordManager.isWeaverAvailable();
	byte[] v113 = SyntheticPasswordManager.passwordTokenToWeaverKey(v97);
	VerifyCredentialResponse v115 = new VerifyCredentialResponse(1);
	ArrayList v116 = SyntheticPasswordManager.toByteArrayList(phiInstruction);
	SyntheticPasswordManager$$ExternalSyntheticLambda1 v117 = new SyntheticPasswordManager$$ExternalSyntheticLambda1(v115,v100);
	this.mWeaver.read(v100, v116, v117);
	VerifyCredentialResponse v114 = v115[0];
	SyntheticPasswordManager$AuthenticationResult.gkResponse = v114;
	int v126 = this.mResponseCode;
	byte[] v127 = this.mGatekeeperHAT;
	[[B v129 = new [[B(1);
	byte[] v130 = SyntheticPasswordCrypto.personalisedHash(this.PERSONALISATION_WEAVER_PASSWORD, v129);
	[B v131 = new [B((v97.length + v130.length));
	System.arraycopy(v97, 0, v131, 0, v97.length);
	System.arraycopy(v130, 0, v131, v97.length, v130.length);
	byte[] v128 = v131;
	0.onCredentialVerified();
	byte[] v137 = SyntheticPasswordManager.loadState("spblob", p2, p4);
	SyntheticPasswordManager$SyntheticPasswordBlob v138 = SyntheticPasswordManager$SyntheticPasswordBlob.fromBytes(v137);
	String v139 = SyntheticPasswordManager.getKeyName(p2);
	byte[] v140 = SyntheticPasswordCrypto.decryptBlobV1(v139, SyntheticPasswordManager$SyntheticPasswordBlob.mContent, phiInstruction);
	SyntheticPasswordManager$AuthenticationToken v141 = new SyntheticPasswordManager$AuthenticationToken(SyntheticPasswordManager$SyntheticPasswordBlob.mVersion);
	boolean v143 = SyntheticPasswordManager.loadEscrowData(v141, p4);
	v141.recreateFromEscrow(phiInstruction);
	SyntheticPasswordManager.createSyntheticPasswordBlob(p2, 0, v141, phiInstruction, phiInstruction, p4);
	SyntheticPasswordManager$AuthenticationToken v136 = v141;
	SyntheticPasswordManager$AuthenticationResult.authToken = v136;
	byte[] v155 = v136.deriveGkPassword();
	VerifyCredentialResponse v156 = SyntheticPasswordManager.verifyChallengeInternal(p1, v155, 0, p4);
	VerifyCredentialResponse v154 = v156;
	SyntheticPasswordManager$AuthenticationResult.gkResponse = v154;
	boolean v158 = SyntheticPasswordManager.hasState("metrics", p2, p4);
	boolean v157 = v158;
	byte[] v160 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveMetricsKey();
	[B v161 = new [B(0);
	VersionedPasswordMetrics v162 = new VersionedPasswordMetrics(p3);
	byte[] v164 = v162.serialize();
	byte[] v165 = SyntheticPasswordCrypto.encrypt(v160, v161, v164);
	SyntheticPasswordManager.saveState("metrics", v165, p2, p4);
	SyntheticPasswordManager$AuthenticationResult v73 = v74;
	byte[] v168 = this.PERSONALIZATION_PASSWORD_HASH;
	SP800Derive v170 = new SP800Derive(this.mSyntheticPassword);
	byte[] v172 = SyntheticPasswordManager.-$$Nest$sfgetPERSONALISATION_CONTEXT();
	byte[] v173 = v170.withContext(v168, v172);
	byte[] v169 = v173;
	byte[] v167 = v169;
	p0.scheduleGc();
	return v167;
}

This is path 3 for the API with depth 2:
public byte[] getHashFactor(LockscreenCredential p1, int p2){
	UserManager v5 = LockSettingsService.getUserManagerFromCache(p1);
	boolean v6 = v5.isCredentialSharableWithParent();
	boolean v4 = v6;
	boolean v8 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
	boolean v7 = v8;
	boolean v3 = phiInstruction;
	String v11 = LockSettingsStorage.getChildProfileLockFile(p1);
	byte[] v12 = LockSettingsStorage.readFile(v11);
	byte[] v10 = v12;
	byte[] v13 = Arrays.copyOfRange(v10, 0, 12);
	byte[] v14 = Arrays.copyOfRange(v10, 12, v10.length);
	StringBuilder v15 = new StringBuilder();
	StringBuilder v17 = v15.append("profile_key_name_decrypt_");
	StringBuilder v18 = v15.append(p2);
	String v19 = v15.toString();
	Key v20 = this.mJavaKeyStore.getKey(v19, 0);
	Cipher v21 = Cipher.getInstance("AES/GCM/NoPadding");
	GCMParameterSpec v22 = new GCMParameterSpec(128,v13);
	v21.init(2, v20, v22);
	byte[] v25 = v21.doFinal(v14);
	LockscreenCredential v27 = new LockscreenCredential(4,v28);
	byte[] v28 = Arrays.copyOf(v25, v25.length);
	LockscreenCredential v26 = v27;
	Arrays.fill(v25, 0);
	boolean v32 = this.mEncryptedPasswords.contains(p1);
	UserInfo v33 = this.mUserManager.getProfileParent(p1);
	String v34 = ManagedProfilePasswordCache.getEncryptionKeyName(p1);
	Provider v35 = this.mKeyStore.getProvider();
	KeyGenerator v36 = KeyGenerator.getInstance("AES", v35);
	KeyGenParameterSpec$Builder v37 = new KeyGenParameterSpec$Builder(v34,3);
	KeyGenParameterSpec$Builder v39 = v37.setKeySize(256);
	String v40 = new String(1);
	KeyGenParameterSpec$Builder v41 = v39.setBlockModes(v40);
	int v42 = SyntheticPasswordCrypto.keyNamespace();
	KeyGenParameterSpec$Builder v43 = v41.setNamespace(v42);
	String v44 = new String(1);
	KeyGenParameterSpec$Builder v45 = v43.setEncryptionPaddings(v44);
	KeyGenParameterSpec$Builder v46 = v45.setUserAuthenticationRequired(1);
	KeyGenParameterSpec$Builder v47 = v46.setUserAuthenticationValidityDurationSeconds(this.CACHE_TIMEOUT_SECONDS);
	KeyGenParameterSpec v48 = v47.build();
	v36.init(v48);
	SecretKey v50 = v36.generateKey();
	Cipher v51 = Cipher.getInstance("AES/GCM/NoPadding");
	LockscreenCredential v9 = v26;
	PersistentDataBlockManagerInternal v55 = LockSettingsStorage.getPersistentDataBlockManager();
	byte[] v56 = v55.getFrpCredentialHandle();
	LockSettingsStorage$PersistentData v57 = LockSettingsStorage$PersistentData.fromBytes(v56);
	LockSettingsStorage$PersistentData v54 = LockSettingsStorage$PersistentData.NONE;
	boolean v53 = phiInstruction;
	LockSettingsService.checkReadPermission("sp-handle", p1);
	long v62 = this.mStorage.getLong("sp-handle", 0, p1);
	long v60 = v62;
	long v59 = v60;
	IBinder v64 = ServiceManager.getService("android.service.gatekeeper.IGateKeeperService");
	LockSettingsService$GateKeeperDiedRecipient v65 = new LockSettingsService$GateKeeperDiedRecipient(LockSettingsService,0);
	v64.linkToDeath(v65, 0);
	IInterface v70 = v64.queryLocalInterface("android.service.gatekeeper.IGateKeeperService");
	IGateKeeperService$Stub$Proxy v71 = new IGateKeeperService$Stub$Proxy(v64);
	IGateKeeperService v69 = v71;
	this.mGateKeeperService = v69;
	IGateKeeperService v63 = v69;
	SyntheticPasswordManager$AuthenticationResult v74 = new SyntheticPasswordManager$AuthenticationResult();
	byte[] v77 = this.mStorage.readSyntheticPasswordState(p4, p2, "pwd");
	byte[] v76 = v77;
	SyntheticPasswordManager$PasswordData v79 = new SyntheticPasswordManager$PasswordData();
	ByteBuffer v81 = ByteBuffer.allocate(v76.length);
	ByteBuffer v82 = v81.put(v76, 0, v76.length);
	Buffer v83 = v81.flip();
	int v84 = v81.getInt();
	this.credentialType = v84;
	byte v85 = v81.get();
	this.scryptN = v85;
	byte v86 = v81.get();
	this.scryptR = v86;
	byte v87 = v81.get();
	this.scryptP = v87;
	int v88 = v81.getInt();
	[B v89 = new [B(v88);
	this.salt = v89;
	ByteBuffer v90 = v81.get(v89);
	int v91 = v81.getInt();
	[B v92 = new [B(v91);
	this.passwordHandle = v92;
	ByteBuffer v93 = v81.get(v92);
	SyntheticPasswordManager$PasswordData v78 = v79;
	int v95 = LockscreenCredential.getType();
	int v96 = LockscreenCredential.getType();
	boolean v94 = phiInstruction;
	boolean v98 = p3.isNone();
	byte[] v99 = SyntheticPasswordManager.scrypt(phiInstruction, SyntheticPasswordManager$PasswordData.salt, (1 << SyntheticPasswordManager$PasswordData.scryptN), (1 << SyntheticPasswordManager$PasswordData.scryptR), (1 << SyntheticPasswordManager$PasswordData.scryptP), 32);
	byte[] v97 = v99;
	byte[] v101 = SyntheticPasswordManager.loadState("weaver", p2, p4);
	ByteBuffer v102 = ByteBuffer.allocate(5);
	ByteBuffer v103 = v102.put(v101, 0, v101.length);
	Buffer v104 = v102.flip();
	byte v105 = v102.get();
	int v100 = -1;
	boolean v112 = SyntheticPasswordManager.isWeaverAvailable();
	byte[] v113 = SyntheticPasswordManager.passwordTokenToWeaverKey(v97);
	[B v115 = new [B(WeaverConfig.keySize);
	VerifyCredentialResponse v116 = new VerifyCredentialResponse(1);
	ArrayList v117 = SyntheticPasswordManager.toByteArrayList(phiInstruction);
	SyntheticPasswordManager$$ExternalSyntheticLambda1 v118 = new SyntheticPasswordManager$$ExternalSyntheticLambda1(v116,v100);
	this.mWeaver.read(v100, v117, v118);
	VerifyCredentialResponse v114 = v116[0];
	SyntheticPasswordManager$AuthenticationResult.gkResponse = v114;
	int v127 = this.mResponseCode;
	byte[] v128 = this.mGatekeeperHAT;
	[[B v130 = new [[B(1);
	byte[] v131 = SyntheticPasswordCrypto.personalisedHash(this.PERSONALISATION_WEAVER_PASSWORD, v130);
	[B v132 = new [B((v97.length + v131.length));
	System.arraycopy(v97, 0, v132, 0, v97.length);
	System.arraycopy(v131, 0, v132, v97.length, v131.length);
	byte[] v129 = v132;
	0.onCredentialVerified();
	byte[] v138 = SyntheticPasswordManager.loadState("spblob", p2, p4);
	SyntheticPasswordManager$SyntheticPasswordBlob v139 = SyntheticPasswordManager$SyntheticPasswordBlob.fromBytes(v138);
	String v140 = SyntheticPasswordManager.getKeyName(p2);
	byte[] v141 = SyntheticPasswordCrypto.decryptBlobV1(v140, SyntheticPasswordManager$SyntheticPasswordBlob.mContent, phiInstruction);
	SyntheticPasswordManager$AuthenticationToken v142 = new SyntheticPasswordManager$AuthenticationToken(SyntheticPasswordManager$SyntheticPasswordBlob.mVersion);
	boolean v144 = SyntheticPasswordManager.loadEscrowData(v142, p4);
	v142.recreateFromEscrow(phiInstruction);
	SyntheticPasswordManager.createSyntheticPasswordBlob(p2, 0, v142, phiInstruction, phiInstruction, p4);
	SyntheticPasswordManager$AuthenticationToken v137 = v142;
	SyntheticPasswordManager$AuthenticationResult.authToken = v137;
	byte[] v156 = v137.deriveGkPassword();
	VerifyCredentialResponse v157 = SyntheticPasswordManager.verifyChallengeInternal(p1, v156, 0, p4);
	VerifyCredentialResponse v155 = v157;
	SyntheticPasswordManager$AuthenticationResult.gkResponse = v155;
	boolean v159 = SyntheticPasswordManager.hasState("metrics", p2, p4);
	boolean v158 = v159;
	byte[] v161 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveMetricsKey();
	[B v162 = new [B(0);
	VersionedPasswordMetrics v163 = new VersionedPasswordMetrics(p3);
	byte[] v165 = v163.serialize();
	byte[] v166 = SyntheticPasswordCrypto.encrypt(v161, v162, v165);
	SyntheticPasswordManager.saveState("metrics", v166, p2, p4);
	SyntheticPasswordManager$AuthenticationResult v73 = v74;
	byte[] v169 = this.PERSONALIZATION_PASSWORD_HASH;
	SP800Derive v171 = new SP800Derive(this.mSyntheticPassword);
	byte[] v173 = SyntheticPasswordManager.-$$Nest$sfgetPERSONALISATION_CONTEXT();
	byte[] v174 = v171.withContext(v169, v173);
	byte[] v170 = v174;
	byte[] v168 = v170;
	p0.scheduleGc();
	return v168;
}
