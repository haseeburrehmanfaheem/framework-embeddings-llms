This is path 1 for the API with depth 2:
public VerifyCredentialResponse verifyTiedProfileChallenge(LockscreenCredential p1, int p2, int p3){
	UserManager v5 = LockSettingsService.getUserManagerFromCache(p1);
	boolean v6 = v5.isCredentialSharableWithParent();
	boolean v4 = v6;
	boolean v8 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
	boolean v7 = v8;
	boolean v3 = phiInstruction;
	UserInfo v9 = this.mUserManager.getProfileParent(p2);
	boolean v11 = p1.isNone();
	ContentResolver v12 = this.mContext.getContentResolver();
	int v14 = Settings$Global.getInt(v12, "device_provisioned", 0);
	int v13 = v14;
	boolean v16 = this.mInjector.hasEnrolledBiometrics(p2);
	boolean v25 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
	long v26 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
	IGateKeeperService v27 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v28 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v27, v26, p1, p2, p3);
	int v29 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	byte[] v30 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
	this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v30);
	IGateKeeperService v32 = LockSettingsService.getGateKeeperService();
	VerifyCredentialResponse v33 = this.mSpManager.verifyChallenge(v32, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
	int v34 = v33.getResponseCode();
	VerifyCredentialResponse v15 = VerifyCredentialResponse.ERROR;
	LockSettingsStorage$CredentialHash v37 = LockSettingsStorage.readPasswordHashIfExists(p2);
	LockSettingsStorage$CredentialHash v38 = LockSettingsStorage.readPatternHashIfExists(p2);
	LockSettingsStorage$CredentialHash v39 = LockSettingsStorage$CredentialHash.createEmptyHash();
	LockSettingsStorage$CredentialHash v36 = v39;
	int v41 = LockscreenCredential.getType();
	int v42 = LockscreenCredential.getType();
	boolean v40 = phiInstruction;
	boolean v44 = p1.isNone();
	boolean v45 = p1.isNone();
	StrictMode.noteDiskRead();
	IGateKeeperService v47 = LockSettingsService.getGateKeeperService();
	byte[] v48 = p1.getCredential();
	GateKeeperResponse v49 = v47.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v48);
	VerifyCredentialResponse v51 = LockSettingsService.convertResponse(phiInstruction);
	boolean v52 = phiInstruction.getShouldReEnroll();
	int v53 = v51.getResponseCode();
	p3.onCredentialVerified();
	LockSettingsService.setUserPasswordMetrics(p1, p2);
	byte[] v57 = p1.getCredential();
	LockSettingsService.unlockKeystore(v57, p2);
	byte[] v65 = LockSettingsService.secretFromCredential(p1);
	LockSettingsService.unlockUser(p2, v65);
	boolean v67 = LockSettingsService.isProfileWithSeparatedLock(p2);
	LockSettingsService.setDeviceUnlockedForUser(p2);
	boolean v69 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
	LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
	VerifyCredentialResponse v43 = v51;
	int v71 = this.mResponseCode;
	Message v73 = this.mHandler.obtainMessage(5, p2, 0);
	v73.sendToTarget();
	VerifyCredentialResponse v10 = v43;
	int v75 = v10.getResponseCode();
	String v78 = LockSettingsStorage.getChildProfileLockFile(p1);
	byte[] v79 = LockSettingsStorage.readFile(v78);
	byte[] v77 = v79;
	byte[] v80 = Arrays.copyOfRange(v77, 0, 12);
	byte[] v81 = Arrays.copyOfRange(v77, 12, v77.length);
	StringBuilder v82 = new StringBuilder();
	StringBuilder v84 = v82.append("profile_key_name_decrypt_");
	StringBuilder v85 = v82.append(p2);
	String v86 = v82.toString();
	Key v87 = this.mJavaKeyStore.getKey(v86, 0);
	Cipher v88 = Cipher.getInstance("AES/GCM/NoPadding");
	GCMParameterSpec v89 = new GCMParameterSpec(128,v80);
	v88.init(2, v87, v89);
	byte[] v92 = v88.doFinal(v81);
	LockscreenCredential v94 = new LockscreenCredential(4,v95);
	byte[] v95 = Arrays.copyOf(v92, v92.length);
	LockscreenCredential v93 = v94;
	Arrays.fill(v92, 0);
	boolean v99 = this.mEncryptedPasswords.contains(p1);
	UserInfo v100 = this.mUserManager.getProfileParent(p1);
	String v101 = ManagedProfilePasswordCache.getEncryptionKeyName(p1);
	Provider v102 = this.mKeyStore.getProvider();
	KeyGenerator v103 = KeyGenerator.getInstance("AES", v102);
	KeyGenParameterSpec$Builder v104 = new KeyGenParameterSpec$Builder(v101,3);
	KeyGenParameterSpec$Builder v106 = v104.setKeySize(256);
	String v107 = new String(1);
	KeyGenParameterSpec$Builder v108 = v106.setBlockModes(v107);
	int v109 = SyntheticPasswordCrypto.keyNamespace();
	KeyGenParameterSpec$Builder v110 = v108.setNamespace(v109);
	String v111 = new String(1);
	KeyGenParameterSpec$Builder v112 = v110.setEncryptionPaddings(v111);
	KeyGenParameterSpec$Builder v113 = v112.setUserAuthenticationRequired(1);
	KeyGenParameterSpec$Builder v114 = v113.setUserAuthenticationValidityDurationSeconds(this.CACHE_TIMEOUT_SECONDS);
	KeyGenParameterSpec v115 = v114.build();
	v103.init(v115);
	SecretKey v117 = v103.generateKey();
	Cipher v118 = Cipher.getInstance("AES/GCM/NoPadding");
	LockscreenCredential v76 = v93;
	boolean v121 = v76.isNone();
	ContentResolver v122 = this.mContext.getContentResolver();
	int v124 = Settings$Global.getInt(v122, "device_provisioned", 0);
	int v123 = v124;
	boolean v126 = this.mInjector.hasEnrolledBiometrics(p2);
	boolean v135 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
	long v136 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
	IGateKeeperService v137 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v138 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v137, v136, p1, p2, p3);
	int v139 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	byte[] v140 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
	this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v140);
	IGateKeeperService v142 = LockSettingsService.getGateKeeperService();
	VerifyCredentialResponse v143 = this.mSpManager.verifyChallenge(v142, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
	int v144 = v143.getResponseCode();
	VerifyCredentialResponse v125 = VerifyCredentialResponse.ERROR;
	LockSettingsStorage$CredentialHash v147 = LockSettingsStorage.readPasswordHashIfExists(p2);
	LockSettingsStorage$CredentialHash v148 = LockSettingsStorage.readPatternHashIfExists(p2);
	LockSettingsStorage$CredentialHash v149 = LockSettingsStorage$CredentialHash.createEmptyHash();
	LockSettingsStorage$CredentialHash v146 = v149;
	int v151 = LockscreenCredential.getType();
	int v152 = LockscreenCredential.getType();
	boolean v150 = phiInstruction;
	boolean v154 = p1.isNone();
	boolean v155 = p1.isNone();
	StrictMode.noteDiskRead();
	IGateKeeperService v157 = LockSettingsService.getGateKeeperService();
	byte[] v158 = p1.getCredential();
	GateKeeperResponse v159 = v157.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v158);
	VerifyCredentialResponse v161 = LockSettingsService.convertResponse(phiInstruction);
	boolean v162 = phiInstruction.getShouldReEnroll();
	int v163 = v161.getResponseCode();
	p3.onCredentialVerified();
	LockSettingsService.setUserPasswordMetrics(p1, p2);
	byte[] v167 = p1.getCredential();
	LockSettingsService.unlockKeystore(v167, p2);
	byte[] v175 = LockSettingsService.secretFromCredential(p1);
	LockSettingsService.unlockUser(p2, v175);
	boolean v177 = LockSettingsService.isProfileWithSeparatedLock(p2);
	LockSettingsService.setDeviceUnlockedForUser(p2);
	boolean v179 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
	LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
	VerifyCredentialResponse v153 = v161;
	int v181 = this.mResponseCode;
	Message v183 = this.mHandler.obtainMessage(5, p2, 0);
	v183.sendToTarget();
	VerifyCredentialResponse v120 = v153;
	p0.scheduleGc();
	return v120;
}

This is path 2 for the API with depth 2:
public VerifyCredentialResponse verifyTiedProfileChallenge(LockscreenCredential p1, int p2, int p3){
	UserManager v5 = LockSettingsService.getUserManagerFromCache(p1);
	boolean v6 = v5.isCredentialSharableWithParent();
	boolean v4 = v6;
	boolean v8 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
	boolean v7 = v8;
	boolean v3 = phiInstruction;
	UserInfo v9 = this.mUserManager.getProfileParent(p2);
	boolean v11 = p1.isNone();
	ContentResolver v12 = this.mContext.getContentResolver();
	int v14 = Settings$Global.getInt(v12, "device_provisioned", 0);
	int v13 = v14;
	boolean v16 = this.mInjector.hasEnrolledBiometrics(p2);
	boolean v25 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
	long v26 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
	IGateKeeperService v27 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v28 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v27, v26, p1, p2, p3);
	int v29 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	byte[] v30 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
	this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v30);
	IGateKeeperService v32 = LockSettingsService.getGateKeeperService();
	VerifyCredentialResponse v33 = this.mSpManager.verifyChallenge(v32, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
	int v34 = v33.getResponseCode();
	VerifyCredentialResponse v15 = VerifyCredentialResponse.ERROR;
	LockSettingsStorage$CredentialHash v37 = LockSettingsStorage.readPasswordHashIfExists(p2);
	LockSettingsStorage$CredentialHash v38 = LockSettingsStorage.readPatternHashIfExists(p2);
	LockSettingsStorage$CredentialHash v39 = LockSettingsStorage$CredentialHash.createEmptyHash();
	LockSettingsStorage$CredentialHash v36 = v39;
	int v41 = LockscreenCredential.getType();
	int v42 = LockscreenCredential.getType();
	boolean v40 = phiInstruction;
	boolean v44 = p1.isNone();
	boolean v45 = p1.isNone();
	StrictMode.noteDiskRead();
	IGateKeeperService v47 = LockSettingsService.getGateKeeperService();
	byte[] v48 = p1.getCredential();
	GateKeeperResponse v49 = v47.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v48);
	VerifyCredentialResponse v51 = LockSettingsService.convertResponse(phiInstruction);
	boolean v52 = phiInstruction.getShouldReEnroll();
	int v53 = v51.getResponseCode();
	p3.onCredentialVerified();
	LockSettingsService.setUserPasswordMetrics(p1, p2);
	byte[] v57 = p1.getCredential();
	LockSettingsService.unlockKeystore(v57, p2);
	byte[] v65 = LockSettingsService.secretFromCredential(p1);
	LockSettingsService.unlockUser(p2, v65);
	boolean v67 = LockSettingsService.isProfileWithSeparatedLock(p2);
	LockSettingsService.setDeviceUnlockedForUser(p2);
	boolean v69 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
	LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
	VerifyCredentialResponse v43 = v51;
	int v71 = this.mResponseCode;
	Message v73 = this.mHandler.obtainMessage(5, p2, 0);
	v73.sendToTarget();
	VerifyCredentialResponse v10 = v43;
	int v75 = v10.getResponseCode();
	String v78 = LockSettingsStorage.getChildProfileLockFile(p1);
	byte[] v79 = LockSettingsStorage.readFile(v78);
	byte[] v77 = v79;
	byte[] v80 = Arrays.copyOfRange(v77, 0, 12);
	byte[] v81 = Arrays.copyOfRange(v77, 12, v77.length);
	StringBuilder v82 = new StringBuilder();
	StringBuilder v84 = v82.append("profile_key_name_decrypt_");
	StringBuilder v85 = v82.append(p2);
	String v86 = v82.toString();
	Key v87 = this.mJavaKeyStore.getKey(v86, 0);
	Cipher v88 = Cipher.getInstance("AES/GCM/NoPadding");
	GCMParameterSpec v89 = new GCMParameterSpec(128,v80);
	v88.init(2, v87, v89);
	byte[] v92 = v88.doFinal(v81);
	LockscreenCredential v94 = new LockscreenCredential(4,v95);
	byte[] v95 = Arrays.copyOf(v92, v92.length);
	LockscreenCredential v93 = v94;
	Arrays.fill(v92, 0);
	boolean v99 = this.mEncryptedPasswords.contains(p1);
	UserInfo v100 = this.mUserManager.getProfileParent(p1);
	String v101 = ManagedProfilePasswordCache.getEncryptionKeyName(p1);
	Provider v102 = this.mKeyStore.getProvider();
	KeyGenerator v103 = KeyGenerator.getInstance("AES", v102);
	KeyGenParameterSpec$Builder v104 = new KeyGenParameterSpec$Builder(v101,3);
	KeyGenParameterSpec$Builder v106 = v104.setKeySize(256);
	String v107 = new String(1);
	KeyGenParameterSpec$Builder v108 = v106.setBlockModes(v107);
	int v109 = SyntheticPasswordCrypto.keyNamespace();
	KeyGenParameterSpec$Builder v110 = v108.setNamespace(v109);
	String v111 = new String(1);
	KeyGenParameterSpec$Builder v112 = v110.setEncryptionPaddings(v111);
	KeyGenParameterSpec$Builder v113 = v112.setUserAuthenticationRequired(1);
	KeyGenParameterSpec$Builder v114 = v113.setUserAuthenticationValidityDurationSeconds(this.CACHE_TIMEOUT_SECONDS);
	KeyGenParameterSpec v115 = v114.build();
	v103.init(v115);
	SecretKey v117 = v103.generateKey();
	Cipher v118 = Cipher.getInstance("AES/GCM/NoPadding");
	LockscreenCredential v76 = v93;
	boolean v121 = v76.isNone();
	ContentResolver v122 = this.mContext.getContentResolver();
	int v124 = Settings$Global.getInt(v122, "device_provisioned", 0);
	int v123 = v124;
	boolean v126 = this.mInjector.hasEnrolledBiometrics(p2);
	boolean v135 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
	long v136 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
	IGateKeeperService v137 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v138 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v137, v136, p1, p2, p3);
	int v139 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	byte[] v140 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
	this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v140);
	IGateKeeperService v142 = LockSettingsService.getGateKeeperService();
	VerifyCredentialResponse v143 = this.mSpManager.verifyChallenge(v142, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
	int v144 = v143.getResponseCode();
	VerifyCredentialResponse v125 = VerifyCredentialResponse.ERROR;
	LockSettingsStorage$CredentialHash v147 = LockSettingsStorage.readPasswordHashIfExists(p2);
	LockSettingsStorage$CredentialHash v148 = LockSettingsStorage.readPatternHashIfExists(p2);
	LockSettingsStorage$CredentialHash v149 = LockSettingsStorage$CredentialHash.createEmptyHash();
	LockSettingsStorage$CredentialHash v146 = v149;
	int v151 = LockscreenCredential.getType();
	int v152 = LockscreenCredential.getType();
	boolean v150 = phiInstruction;
	boolean v154 = p1.isNone();
	boolean v155 = p1.isNone();
	StrictMode.noteDiskRead();
	IGateKeeperService v157 = LockSettingsService.getGateKeeperService();
	byte[] v158 = p1.getCredential();
	GateKeeperResponse v159 = v157.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v158);
	VerifyCredentialResponse v161 = LockSettingsService.convertResponse(phiInstruction);
	boolean v162 = phiInstruction.getShouldReEnroll();
	int v163 = v161.getResponseCode();
	p3.onCredentialVerified();
	LockSettingsService.setUserPasswordMetrics(p1, p2);
	byte[] v167 = p1.getCredential();
	LockSettingsService.unlockKeystore(v167, p2);
	byte[] v175 = LockSettingsService.secretFromCredential(p1);
	LockSettingsService.unlockUser(p2, v175);
	boolean v177 = LockSettingsService.isProfileWithSeparatedLock(p2);
	LockSettingsService.setDeviceUnlockedForUser(p2);
	boolean v179 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
	LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
	VerifyCredentialResponse v153 = v161;
	int v181 = this.mResponseCode;
	Message v183 = this.mHandler.obtainMessage(5, p2, 0);
	v183.sendToTarget();
	VerifyCredentialResponse v120 = v153;
	p0.scheduleGc();
	return v120;
}

This is path 3 for the API with depth 2:
public VerifyCredentialResponse verifyTiedProfileChallenge(LockscreenCredential p1, int p2, int p3){
	UserManager v5 = LockSettingsService.getUserManagerFromCache(p1);
	boolean v6 = v5.isCredentialSharableWithParent();
	boolean v4 = v6;
	boolean v8 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
	boolean v7 = v8;
	boolean v3 = phiInstruction;
	UserInfo v9 = this.mUserManager.getProfileParent(p2);
	boolean v11 = p1.isNone();
	ContentResolver v12 = this.mContext.getContentResolver();
	int v14 = Settings$Global.getInt(v12, "device_provisioned", 0);
	int v13 = v14;
	boolean v16 = this.mInjector.hasEnrolledBiometrics(p2);
	boolean v25 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
	long v26 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
	IGateKeeperService v27 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v28 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v27, v26, p1, p2, p3);
	int v29 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	byte[] v30 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
	this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v30);
	IGateKeeperService v32 = LockSettingsService.getGateKeeperService();
	VerifyCredentialResponse v33 = this.mSpManager.verifyChallenge(v32, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
	int v34 = v33.getResponseCode();
	VerifyCredentialResponse v15 = VerifyCredentialResponse.ERROR;
	LockSettingsStorage$CredentialHash v37 = LockSettingsStorage.readPasswordHashIfExists(p2);
	LockSettingsStorage$CredentialHash v38 = LockSettingsStorage.readPatternHashIfExists(p2);
	LockSettingsStorage$CredentialHash v36 = v38;
	int v40 = LockscreenCredential.getType();
	int v41 = LockscreenCredential.getType();
	boolean v39 = phiInstruction;
	boolean v43 = p1.isNone();
	boolean v44 = p1.isNone();
	StrictMode.noteDiskRead();
	IGateKeeperService v46 = LockSettingsService.getGateKeeperService();
	byte[] v47 = p1.getCredential();
	GateKeeperResponse v48 = v46.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v47);
	VerifyCredentialResponse v50 = LockSettingsService.convertResponse(phiInstruction);
	boolean v51 = phiInstruction.getShouldReEnroll();
	int v52 = v50.getResponseCode();
	p3.onCredentialVerified();
	LockSettingsService.setUserPasswordMetrics(p1, p2);
	byte[] v56 = p1.getCredential();
	LockSettingsService.unlockKeystore(v56, p2);
	byte[] v64 = LockSettingsService.secretFromCredential(p1);
	LockSettingsService.unlockUser(p2, v64);
	boolean v66 = LockSettingsService.isProfileWithSeparatedLock(p2);
	LockSettingsService.setDeviceUnlockedForUser(p2);
	boolean v68 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
	LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
	VerifyCredentialResponse v42 = v50;
	int v70 = this.mResponseCode;
	Message v72 = this.mHandler.obtainMessage(5, p2, 0);
	v72.sendToTarget();
	VerifyCredentialResponse v10 = v42;
	int v74 = v10.getResponseCode();
	String v77 = LockSettingsStorage.getChildProfileLockFile(p1);
	byte[] v78 = LockSettingsStorage.readFile(v77);
	byte[] v76 = v78;
	byte[] v79 = Arrays.copyOfRange(v76, 0, 12);
	byte[] v80 = Arrays.copyOfRange(v76, 12, v76.length);
	StringBuilder v81 = new StringBuilder();
	StringBuilder v83 = v81.append("profile_key_name_decrypt_");
	StringBuilder v84 = v81.append(p2);
	String v85 = v81.toString();
	Key v86 = this.mJavaKeyStore.getKey(v85, 0);
	Cipher v87 = Cipher.getInstance("AES/GCM/NoPadding");
	GCMParameterSpec v88 = new GCMParameterSpec(128,v79);
	v87.init(2, v86, v88);
	byte[] v91 = v87.doFinal(v80);
	LockscreenCredential v93 = new LockscreenCredential(4,v94);
	byte[] v94 = Arrays.copyOf(v91, v91.length);
	LockscreenCredential v92 = v93;
	Arrays.fill(v91, 0);
	boolean v98 = this.mEncryptedPasswords.contains(p1);
	UserInfo v99 = this.mUserManager.getProfileParent(p1);
	String v100 = ManagedProfilePasswordCache.getEncryptionKeyName(p1);
	Provider v101 = this.mKeyStore.getProvider();
	KeyGenerator v102 = KeyGenerator.getInstance("AES", v101);
	KeyGenParameterSpec$Builder v103 = new KeyGenParameterSpec$Builder(v100,3);
	KeyGenParameterSpec$Builder v105 = v103.setKeySize(256);
	String v106 = new String(1);
	KeyGenParameterSpec$Builder v107 = v105.setBlockModes(v106);
	int v108 = SyntheticPasswordCrypto.keyNamespace();
	KeyGenParameterSpec$Builder v109 = v107.setNamespace(v108);
	String v110 = new String(1);
	KeyGenParameterSpec$Builder v111 = v109.setEncryptionPaddings(v110);
	KeyGenParameterSpec$Builder v112 = v111.setUserAuthenticationRequired(1);
	KeyGenParameterSpec$Builder v113 = v112.setUserAuthenticationValidityDurationSeconds(this.CACHE_TIMEOUT_SECONDS);
	KeyGenParameterSpec v114 = v113.build();
	v102.init(v114);
	SecretKey v116 = v102.generateKey();
	Cipher v117 = Cipher.getInstance("AES/GCM/NoPadding");
	LockscreenCredential v75 = v92;
	boolean v120 = v75.isNone();
	ContentResolver v121 = this.mContext.getContentResolver();
	int v123 = Settings$Global.getInt(v121, "device_provisioned", 0);
	int v122 = v123;
	boolean v125 = this.mInjector.hasEnrolledBiometrics(p2);
	boolean v134 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
	long v135 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
	IGateKeeperService v136 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v137 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v136, v135, p1, p2, p3);
	int v138 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	byte[] v139 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
	this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v139);
	IGateKeeperService v141 = LockSettingsService.getGateKeeperService();
	VerifyCredentialResponse v142 = this.mSpManager.verifyChallenge(v141, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
	int v143 = v142.getResponseCode();
	VerifyCredentialResponse v124 = VerifyCredentialResponse.ERROR;
	LockSettingsStorage$CredentialHash v146 = LockSettingsStorage.readPasswordHashIfExists(p2);
	LockSettingsStorage$CredentialHash v147 = LockSettingsStorage.readPatternHashIfExists(p2);
	LockSettingsStorage$CredentialHash v148 = LockSettingsStorage$CredentialHash.createEmptyHash();
	LockSettingsStorage$CredentialHash v145 = v148;
	int v150 = LockscreenCredential.getType();
	int v151 = LockscreenCredential.getType();
	boolean v149 = phiInstruction;
	boolean v153 = p1.isNone();
	boolean v154 = p1.isNone();
	StrictMode.noteDiskRead();
	IGateKeeperService v156 = LockSettingsService.getGateKeeperService();
	byte[] v157 = p1.getCredential();
	GateKeeperResponse v158 = v156.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v157);
	VerifyCredentialResponse v160 = LockSettingsService.convertResponse(phiInstruction);
	boolean v161 = phiInstruction.getShouldReEnroll();
	int v162 = v160.getResponseCode();
	p3.onCredentialVerified();
	LockSettingsService.setUserPasswordMetrics(p1, p2);
	byte[] v166 = p1.getCredential();
	LockSettingsService.unlockKeystore(v166, p2);
	byte[] v174 = LockSettingsService.secretFromCredential(p1);
	LockSettingsService.unlockUser(p2, v174);
	boolean v176 = LockSettingsService.isProfileWithSeparatedLock(p2);
	LockSettingsService.setDeviceUnlockedForUser(p2);
	boolean v178 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
	LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
	VerifyCredentialResponse v152 = v160;
	int v180 = this.mResponseCode;
	Message v182 = this.mHandler.obtainMessage(5, p2, 0);
	v182.sendToTarget();
	VerifyCredentialResponse v119 = v152;
	p0.scheduleGc();
	return v119;
}
