This is path 1 for the API with depth 2:
public VerifyCredentialResponse checkCredential(LockscreenCredential p1, int p2, ICheckCredentialProgressCallback p3){
	boolean v4 = p1.isNone();
	ContentResolver v5 = this.mContext.getContentResolver();
	int v7 = Settings$Global.getInt(v5, "device_provisioned", 0);
	int v6 = v7;
	boolean v9 = this.mInjector.hasEnrolledBiometrics(p2);
	boolean v18 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
	long v19 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
	IGateKeeperService v20 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v21 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v20, v19, p1, p2, p3);
	int v22 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	byte[] v23 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
	this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v23);
	IGateKeeperService v25 = LockSettingsService.getGateKeeperService();
	VerifyCredentialResponse v26 = this.mSpManager.verifyChallenge(v25, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
	int v27 = v26.getResponseCode();
	VerifyCredentialResponse v8 = VerifyCredentialResponse.ERROR;
	LockSettingsStorage$CredentialHash v30 = LockSettingsStorage.readPasswordHashIfExists(p2);
	LockSettingsStorage$CredentialHash v31 = LockSettingsStorage.readPatternHashIfExists(p2);
	LockSettingsStorage$CredentialHash v32 = LockSettingsStorage$CredentialHash.createEmptyHash();
	LockSettingsStorage$CredentialHash v29 = v32;
	int v34 = LockscreenCredential.getType();
	int v35 = LockscreenCredential.getType();
	boolean v33 = phiInstruction;
	boolean v37 = p1.isNone();
	boolean v38 = p1.isNone();
	StrictMode.noteDiskRead();
	IGateKeeperService v40 = LockSettingsService.getGateKeeperService();
	byte[] v41 = p1.getCredential();
	GateKeeperResponse v42 = v40.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v41);
	VerifyCredentialResponse v44 = LockSettingsService.convertResponse(phiInstruction);
	boolean v45 = phiInstruction.getShouldReEnroll();
	int v46 = v44.getResponseCode();
	p3.onCredentialVerified();
	LockSettingsService.setUserPasswordMetrics(p1, p2);
	byte[] v50 = p1.getCredential();
	LockSettingsService.unlockKeystore(v50, p2);
	byte[] v58 = LockSettingsService.secretFromCredential(p1);
	LockSettingsService.unlockUser(p2, v58);
	boolean v60 = LockSettingsService.isProfileWithSeparatedLock(p2);
	LockSettingsService.setDeviceUnlockedForUser(p2);
	boolean v62 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
	LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
	VerifyCredentialResponse v36 = v44;
	int v64 = this.mResponseCode;
	Message v66 = this.mHandler.obtainMessage(5, p2, 0);
	v66.sendToTarget();
	VerifyCredentialResponse v3 = v36;
	p0.scheduleGc();
	return v3;
}

This is path 2 for the API with depth 2:
public VerifyCredentialResponse checkCredential(LockscreenCredential p1, int p2, ICheckCredentialProgressCallback p3){
	boolean v4 = p1.isNone();
	ContentResolver v5 = this.mContext.getContentResolver();
	int v7 = Settings$Global.getInt(v5, "device_provisioned", 0);
	int v6 = v7;
	boolean v9 = this.mInjector.hasEnrolledBiometrics(p2);
	boolean v18 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
	long v19 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
	IGateKeeperService v20 = LockSettingsService.getGateKeeperService();
	SyntheticPasswordManager$AuthenticationResult v21 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v20, v19, p1, p2, p3);
	int v22 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
	byte[] v23 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
	this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v23);
	IGateKeeperService v25 = LockSettingsService.getGateKeeperService();
	VerifyCredentialResponse v26 = this.mSpManager.verifyChallenge(v25, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
	int v27 = v26.getResponseCode();
	VerifyCredentialResponse v8 = VerifyCredentialResponse.ERROR;
	LockSettingsStorage$CredentialHash v30 = LockSettingsStorage.readPasswordHashIfExists(p2);
	LockSettingsStorage$CredentialHash v31 = LockSettingsStorage.readPatternHashIfExists(p2);
	LockSettingsStorage$CredentialHash v29 = v31;
	int v33 = LockscreenCredential.getType();
	int v34 = LockscreenCredential.getType();
	boolean v32 = phiInstruction;
	boolean v36 = p1.isNone();
	boolean v37 = p1.isNone();
	StrictMode.noteDiskRead();
	IGateKeeperService v39 = LockSettingsService.getGateKeeperService();
	byte[] v40 = p1.getCredential();
	GateKeeperResponse v41 = v39.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v40);
	VerifyCredentialResponse v43 = LockSettingsService.convertResponse(phiInstruction);
	boolean v44 = phiInstruction.getShouldReEnroll();
	int v45 = v43.getResponseCode();
	p3.onCredentialVerified();
	LockSettingsService.setUserPasswordMetrics(p1, p2);
	byte[] v49 = p1.getCredential();
	LockSettingsService.unlockKeystore(v49, p2);
	byte[] v57 = LockSettingsService.secretFromCredential(p1);
	LockSettingsService.unlockUser(p2, v57);
	boolean v59 = LockSettingsService.isProfileWithSeparatedLock(p2);
	LockSettingsService.setDeviceUnlockedForUser(p2);
	boolean v61 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
	LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
	VerifyCredentialResponse v35 = v43;
	int v63 = this.mResponseCode;
	Message v65 = this.mHandler.obtainMessage(5, p2, 0);
	v65.sendToTarget();
	VerifyCredentialResponse v3 = v35;
	p0.scheduleGc();
	return v3;
}
