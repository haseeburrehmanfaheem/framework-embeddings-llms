This is path 1 for the API with depth 2:
public void moveTaskToFront(IApplicationThread p1, String p2, int p3, int p4, Bundle p5){
	Object v2 = new Object(1);
	Long v3 = Long.valueOf(p3);
	ProtoLogImpl v6 = new ProtoLogImpl(v7,1048576,v9);
	File v7 = new File("/data/misc/wmtrace/wm_log.winscope");
	ProtoLogViewerConfigReader v9 = new ProtoLogViewerConfigReader();
	this.sServiceInstance = v6;
	ProtoLogImpl v5 = this.sServiceInstance;
	boolean v13 = p1.isLogToProto();
	BaseProtoLogImpl.logToProto(p2, p3, p5);
	boolean v15 = p1.isLogToLogcat();
	String v16 = p1.getTag();
	BaseProtoLogImpl.logToLogcat(v16, BaseProtoLogImpl$LogLevel.DEBUG, p2, p4, p5);
	SafeActivityOptions v22 = new SafeActivityOptions(v23);
	ActivityOptions v24 = new ActivityOptions(p1);
	ActivityOptions v23 = phiInstruction;
	SafeActivityOptions v21 = phiInstruction;
	int v28 = Binder.getCallingPid();
	int v29 = Binder.getCallingUid();
	long v33 = Binder.clearCallingIdentity();
	IBinder v35 = p1.asBinder();
	ArrayMap v36 = this.mProcessNames.getMap();
	int v37 = v36.size();
	Object v38 = v36.valueAt(phiInstruction);
	int v39 = v38.size();
	Object v40 = v38.valueAt(phiInstruction);
	boolean v41 = v40.hasThread();
	IApplicationThread v42 = v40.getThread();
	IBinder v43 = v42.asBinder();
	WindowProcessController v34 = v40;
	ActivityStartController v44 = this.mActivityStartController;
	ActivityStarter v46 = this.mFactory.obtain();
	ActivityStarter v47 = v46.setIntent(0);
	ActivityStarter v48 = v47.setReason("moveTaskToFront");
	ActivityStarter v45 = v48;
	boolean v57 = ActivityTaskManagerService.mActiveUids.hasNonAppVisibleWindow(v29);
	boolean v49 = 0;
	boolean v59 = this.mAmInternal.isBackgroundActivityStartsEnabled();
	boolean v58 = v59;
	Task v61 = RootWindowContainer.anyTaskForId(p3, 2);
	Task v60 = v61;
	LockTaskController v62 = this.mLockTaskController;
	boolean v64 = LockTaskController.isLockTaskModeViolation(v60, 0);
	boolean v63 = v64;
	ActivityOptions v66 = SafeActivityOptions.getOptions(0, 0, 0, this.mTaskSupervisor);
	ActivityOptions v65 = v66;
	Task v68 = v60.getRootTask();
	Binder.restoreCallingIdentity(v33);
	return;
}

This is path 2 for the API with depth 2:
public void moveTaskToFront(IApplicationThread p1, String p2, int p3, int p4, Bundle p5){
	Object v2 = new Object(1);
	Long v3 = Long.valueOf(p3);
	ProtoLogImpl v6 = new ProtoLogImpl(v7,1048576,v9);
	File v7 = new File("/data/misc/wmtrace/wm_log.winscope");
	ProtoLogViewerConfigReader v9 = new ProtoLogViewerConfigReader();
	this.sServiceInstance = v6;
	ProtoLogImpl v5 = this.sServiceInstance;
	boolean v13 = p1.isLogToProto();
	BaseProtoLogImpl.logToProto(p2, p3, p5);
	boolean v15 = p1.isLogToLogcat();
	String v16 = p1.getTag();
	BaseProtoLogImpl.logToLogcat(v16, BaseProtoLogImpl$LogLevel.DEBUG, p2, p4, p5);
	WindowManagerThreadPriorityBooster.boost();
	SafeActivityOptions v23 = new SafeActivityOptions(v24);
	ActivityOptions v25 = new ActivityOptions(p1);
	ActivityOptions v24 = phiInstruction;
	SafeActivityOptions v22 = phiInstruction;
	int v29 = Binder.getCallingPid();
	int v30 = Binder.getCallingUid();
	long v34 = Binder.clearCallingIdentity();
	IBinder v36 = p1.asBinder();
	ArrayMap v37 = this.mProcessNames.getMap();
	int v38 = v37.size();
	Object v39 = v37.valueAt(phiInstruction);
	int v40 = v39.size();
	Object v41 = v39.valueAt(phiInstruction);
	boolean v42 = v41.hasThread();
	IApplicationThread v43 = v41.getThread();
	IBinder v44 = v43.asBinder();
	WindowProcessController v35 = v41;
	ActivityStartController v45 = this.mActivityStartController;
	ActivityStarter v47 = this.mFactory.obtain();
	ActivityStarter v48 = v47.setIntent(0);
	ActivityStarter v49 = v48.setReason("moveTaskToFront");
	ActivityStarter v46 = v49;
	boolean v58 = ActivityTaskManagerService.mActiveUids.hasNonAppVisibleWindow(v30);
	boolean v50 = 0;
	boolean v60 = this.mAmInternal.isBackgroundActivityStartsEnabled();
	boolean v59 = v60;
	Task v62 = RootWindowContainer.anyTaskForId(p3, 2);
	Task v61 = v62;
	LockTaskController v63 = this.mLockTaskController;
	boolean v65 = LockTaskController.isLockTaskModeViolation(v61, 0);
	boolean v64 = v65;
	ActivityOptions v67 = SafeActivityOptions.getOptions(0, 0, 0, this.mTaskSupervisor);
	ActivityOptions v66 = v67;
	Task v69 = v61.getRootTask();
	Binder.restoreCallingIdentity(v34);
	return;
}

This is path 3 for the API with depth 2:
public void moveTaskToFront(IApplicationThread p1, String p2, int p3, int p4, Bundle p5){
	Object v2 = new Object(1);
	Long v3 = Long.valueOf(p3);
	ProtoLogImpl v6 = new ProtoLogImpl(v7,1048576,v9);
	File v7 = new File("/data/misc/wmtrace/wm_log.winscope");
	ProtoLogViewerConfigReader v9 = new ProtoLogViewerConfigReader();
	this.sServiceInstance = v6;
	ProtoLogImpl v5 = this.sServiceInstance;
	boolean v13 = p1.isLogToProto();
	BaseProtoLogImpl.logToProto(p2, p3, p5);
	boolean v15 = p1.isLogToLogcat();
	String v16 = p1.getTag();
	BaseProtoLogImpl.logToLogcat(v16, BaseProtoLogImpl$LogLevel.DEBUG, p2, p4, p5);
	SafeActivityOptions v22 = new SafeActivityOptions(v23);
	ActivityOptions v24 = new ActivityOptions(p1);
	ActivityOptions v23 = phiInstruction;
	SafeActivityOptions v21 = phiInstruction;
	int v28 = Binder.getCallingPid();
	int v29 = Binder.getCallingUid();
	long v33 = Binder.clearCallingIdentity();
	IBinder v35 = p1.asBinder();
	ArrayMap v36 = this.mProcessNames.getMap();
	int v37 = v36.size();
	Object v38 = v36.valueAt(phiInstruction);
	int v39 = v38.size();
	Object v40 = v38.valueAt(phiInstruction);
	boolean v41 = v40.hasThread();
	IApplicationThread v42 = v40.getThread();
	IBinder v43 = v42.asBinder();
	WindowProcessController v34 = v40;
	ActivityStartController v44 = this.mActivityStartController;
	ActivityStarter v46 = this.mFactory.obtain();
	ActivityStarter v47 = v46.setIntent(0);
	ActivityStarter v48 = v47.setReason("moveTaskToFront");
	ActivityStarter v45 = v48;
	boolean v57 = ActivityTaskManagerService.mActiveUids.hasNonAppVisibleWindow(v29);
	boolean v49 = 0;
	boolean v59 = this.mAmInternal.isBackgroundActivityStartsEnabled();
	boolean v58 = v59;
	Task v61 = RootWindowContainer.anyTaskForId(p3, 2);
	Task v60 = v61;
	LockTaskController v62 = this.mLockTaskController;
	boolean v64 = LockTaskController.isLockTaskModeViolation(v60, 0);
	boolean v63 = v64;
	ActivityOptions v66 = SafeActivityOptions.getOptions(0, 0, 0, this.mTaskSupervisor);
	ActivityOptions v65 = v66;
	Task v68 = v60.getRootTask();
	Binder.restoreCallingIdentity(v33);
	WindowManagerThreadPriorityBooster.reset();
	return;
}
