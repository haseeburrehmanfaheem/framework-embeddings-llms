This is path 1 for the API with depth 2:
public boolean resizeTask(int p1, Rect p2, int p3){
	long v5 = Binder.clearCallingIdentity();
	AppTransition$$ExternalSyntheticLambda2 v11 = new AppTransition$$ExternalSyntheticLambda2();
	ArgumentPlaceholder v13 = PooledLambda.__(Tas.class);
	Integer v14 = Integer.valueOf(p1);
	PooledPredicate v15 = PooledLambda.obtainPredicate(v11, v13, v14);
	Task v16 = RootWindowContainer.getTask(v15);
	v15.recycle();
	Task v18 = RootWindowContainer.getOrCreateRootTask(0, 0, v16, 0);
	Task v19 = v16.getRootTask();
	boolean v20 = v16.reparent(v18, 0, phiInstruction, 1, 1, "anyTaskForId");
	Task v10 = v16;
	Task v9 = v10;
	WindowConfiguration v21 = v9.getWindowConfiguration();
	boolean v22 = v21.canResizeTask();
	boolean v25 = WindowManagerService.mWindowPlacerLocked.isLayoutDeferred();
	this.mLayoutReasons = 0;
	WindowManagerService.mWindowPlacerLocked.deferLayout();
	WindowContainer v27 = this.mParent;
	boolean v29 = Task.inFreeformWindowingMode();
	int v30 = p1.width();
	int v31 = p1.height();
	Rect v32 = Task.getRequestedOverrideBounds();
	boolean v33 = v32.isEmpty();
	int v34 = v32.width();
	int v35 = v32.height();
	boolean v28 = phiInstruction;
	StringBuilder v36 = new StringBuilder();
	StringBuilder v38 = v36.append("resizeTask_");
	StringBuilder v39 = v36.append(this.mTaskId);
	String v40 = v36.toString();
	Trace.traceBegin(32, v40);
	Configuration v42 = this.mResolvedOverrideConfiguration;
	this.mTmpConfig.setTo(v42);
	boolean v45 = Task.isRootTask();
	Task v46 = Task.getRootTask();
	Task v47 = Task.getRootTask();
	DisplayContent v48 = v47.getDisplayContent();
	DisplayInfo v49 = phiInstruction.getDisplayInfo();
	int v50 = Task.setBounds(p1);
	this.mRotation = phiInstruction;
	Task.updateSurfacePositionNonOrganized();
	int v44 = v50;
	Configuration v52 = this.mResolvedOverrideConfiguration;
	boolean v53 = this.mTmpConfig.equals(v52);
	WindowContainer v55 = Task.getParent();
	Task$$ExternalSyntheticLambda6 v56 = new Task$$ExternalSyntheticLambda6();
	ActivityRecord v58 = Task.getActivity(v56);
	ActivityRecord v54 = v58;
	boolean v60 = ActivityRecord.ensureActivityConfiguration(0, p3, 0);
	boolean v59 = v60;
	RootWindowContainer.ensureActivitiesVisible(v54, 0, p3, 1);
	boolean v64 = RootWindowContainer.resumeFocusedTasksTopActivities(0, 0, 0);
	boolean v63 = v64;
	Rect v66 = Task.getRequestedOverrideBounds();
	int v67 = Task.setBounds(v66, phiInstruction);
	DisplayContent v68 = Task.getDisplayContent();
	v68.layoutAndAssignWindowLayersIfNeeded();
	DisplayContent v71 = Task.getDisplayContent();
	Task.saveLaunchingStateIfNeeded(v71);
	Trace.traceEnd(32);
	WindowManagerService.mWindowPlacerLocked.continueLayout(phiInstruction);
	boolean v23 = phiInstruction;
	Binder.restoreCallingIdentity(v5);
	return v23;
}

This is path 2 for the API with depth 2:
public boolean resizeTask(int p1, Rect p2, int p3){
	long v5 = Binder.clearCallingIdentity();
	WindowManagerThreadPriorityBooster.boost();
	AppTransition$$ExternalSyntheticLambda2 v12 = new AppTransition$$ExternalSyntheticLambda2();
	ArgumentPlaceholder v14 = PooledLambda.__(Tas.class);
	Integer v15 = Integer.valueOf(p1);
	PooledPredicate v16 = PooledLambda.obtainPredicate(v12, v14, v15);
	Task v17 = RootWindowContainer.getTask(v16);
	v16.recycle();
	Task v19 = RootWindowContainer.getOrCreateRootTask(0, 0, v17, 0);
	Task v20 = v17.getRootTask();
	boolean v21 = v17.reparent(v19, 0, phiInstruction, 1, 1, "anyTaskForId");
	Task v11 = v17;
	Task v10 = v11;
	WindowConfiguration v22 = v10.getWindowConfiguration();
	boolean v23 = v22.canResizeTask();
	boolean v26 = WindowManagerService.mWindowPlacerLocked.isLayoutDeferred();
	this.mLayoutReasons = 0;
	WindowManagerService.mWindowPlacerLocked.deferLayout();
	WindowContainer v28 = this.mParent;
	boolean v30 = Task.inFreeformWindowingMode();
	int v31 = p1.width();
	int v32 = p1.height();
	Rect v33 = Task.getRequestedOverrideBounds();
	boolean v34 = v33.isEmpty();
	int v35 = v33.width();
	int v36 = v33.height();
	boolean v29 = phiInstruction;
	StringBuilder v37 = new StringBuilder();
	StringBuilder v39 = v37.append("resizeTask_");
	StringBuilder v40 = v37.append(this.mTaskId);
	String v41 = v37.toString();
	Trace.traceBegin(32, v41);
	Configuration v43 = this.mResolvedOverrideConfiguration;
	this.mTmpConfig.setTo(v43);
	boolean v46 = Task.isRootTask();
	Task v47 = Task.getRootTask();
	Task v48 = Task.getRootTask();
	DisplayContent v49 = v48.getDisplayContent();
	DisplayInfo v50 = phiInstruction.getDisplayInfo();
	int v51 = Task.setBounds(p1);
	this.mRotation = phiInstruction;
	Task.updateSurfacePositionNonOrganized();
	int v45 = v51;
	Configuration v53 = this.mResolvedOverrideConfiguration;
	boolean v54 = this.mTmpConfig.equals(v53);
	WindowContainer v56 = Task.getParent();
	Task$$ExternalSyntheticLambda6 v57 = new Task$$ExternalSyntheticLambda6();
	ActivityRecord v59 = Task.getActivity(v57);
	ActivityRecord v55 = v59;
	boolean v61 = ActivityRecord.ensureActivityConfiguration(0, p3, 0);
	boolean v60 = v61;
	RootWindowContainer.ensureActivitiesVisible(v55, 0, p3, 1);
	boolean v65 = RootWindowContainer.resumeFocusedTasksTopActivities(0, 0, 0);
	boolean v64 = v65;
	Rect v67 = Task.getRequestedOverrideBounds();
	int v68 = Task.setBounds(v67, phiInstruction);
	DisplayContent v69 = Task.getDisplayContent();
	v69.layoutAndAssignWindowLayersIfNeeded();
	DisplayContent v72 = Task.getDisplayContent();
	Task.saveLaunchingStateIfNeeded(v72);
	Trace.traceEnd(32);
	WindowManagerService.mWindowPlacerLocked.continueLayout(phiInstruction);
	boolean v24 = phiInstruction;
	Binder.restoreCallingIdentity(v5);
	return v24;
}

This is path 3 for the API with depth 2:
public boolean resizeTask(int p1, Rect p2, int p3){
	long v5 = Binder.clearCallingIdentity();
	AppTransition$$ExternalSyntheticLambda2 v11 = new AppTransition$$ExternalSyntheticLambda2();
	ArgumentPlaceholder v13 = PooledLambda.__(Tas.class);
	Integer v14 = Integer.valueOf(p1);
	PooledPredicate v15 = PooledLambda.obtainPredicate(v11, v13, v14);
	Task v16 = RootWindowContainer.getTask(v15);
	v15.recycle();
	Task v18 = RootWindowContainer.getOrCreateRootTask(0, 0, v16, 0);
	Task v19 = v16.getRootTask();
	boolean v20 = v16.reparent(v18, 0, phiInstruction, 1, 1, "anyTaskForId");
	Task v10 = v16;
	Task v9 = v10;
	WindowConfiguration v21 = v9.getWindowConfiguration();
	boolean v22 = v21.canResizeTask();
	boolean v25 = WindowManagerService.mWindowPlacerLocked.isLayoutDeferred();
	this.mLayoutReasons = 0;
	WindowManagerService.mWindowPlacerLocked.deferLayout();
	WindowContainer v27 = this.mParent;
	boolean v29 = Task.inFreeformWindowingMode();
	int v30 = p1.width();
	int v31 = p1.height();
	Rect v32 = Task.getRequestedOverrideBounds();
	boolean v33 = v32.isEmpty();
	int v34 = v32.width();
	int v35 = v32.height();
	boolean v28 = phiInstruction;
	StringBuilder v36 = new StringBuilder();
	StringBuilder v38 = v36.append("resizeTask_");
	StringBuilder v39 = v36.append(this.mTaskId);
	String v40 = v36.toString();
	Trace.traceBegin(32, v40);
	Configuration v42 = this.mResolvedOverrideConfiguration;
	this.mTmpConfig.setTo(v42);
	boolean v45 = Task.isRootTask();
	Task v46 = Task.getRootTask();
	Task v47 = Task.getRootTask();
	DisplayContent v48 = v47.getDisplayContent();
	DisplayInfo v49 = phiInstruction.getDisplayInfo();
	int v50 = Task.setBounds(p1);
	this.mRotation = phiInstruction;
	Task.updateSurfacePositionNonOrganized();
	int v44 = v50;
	Configuration v52 = this.mResolvedOverrideConfiguration;
	boolean v53 = this.mTmpConfig.equals(v52);
	WindowContainer v55 = Task.getParent();
	Task$$ExternalSyntheticLambda6 v56 = new Task$$ExternalSyntheticLambda6();
	ActivityRecord v58 = Task.getActivity(v56);
	ActivityRecord v54 = v58;
	boolean v60 = ActivityRecord.ensureActivityConfiguration(0, p3, 0);
	boolean v59 = v60;
	RootWindowContainer.ensureActivitiesVisible(v54, 0, p3, 1);
	boolean v64 = RootWindowContainer.resumeFocusedTasksTopActivities(0, 0, 0);
	boolean v63 = v64;
	Rect v66 = Task.getRequestedOverrideBounds();
	int v67 = Task.setBounds(v66, phiInstruction);
	DisplayContent v68 = Task.getDisplayContent();
	v68.layoutAndAssignWindowLayersIfNeeded();
	DisplayContent v71 = Task.getDisplayContent();
	Task.saveLaunchingStateIfNeeded(v71);
	Trace.traceEnd(32);
	WindowManagerService.mWindowPlacerLocked.continueLayout(phiInstruction);
	boolean v23 = phiInstruction;
	WindowManagerThreadPriorityBooster.reset();
	Binder.restoreCallingIdentity(v5);
	return v23;
}
