This is path 1 for the API with depth 2:
public VerifyCredentialResponse verifyTiedProfileChallenge(LockscreenCredential p1, int p2, int p3){
	UserManager v4 = LockSettingsService.getUserManagerFromCache(p1);
	boolean v5 = v4.isCredentialSharableWithParent();
	boolean v3 = v5;
	if (v3 == 0) {
		boolean v7 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
		boolean v6 = v7;
		if (v6 != 0) {
			boolean v2 = ;
			if (v2 == 0) {
				UserInfo v8 = this.mUserManager.getProfileParent(p2);
				if (p1 == 0) {
					boolean v10 = p1.isNone();
					if (v10 != 0) {
						if (UserInfo.id != -9999) {
							ContentResolver v11 = this.mContext.getContentResolver();
							int v13 = Settings$Global.getInt(v11, "device_provisioned", 0);
							int v12 = v13;
							if (v12 == 0) {
								boolean v15 = this.mInjector.hasEnrolledBiometrics(p2);
								if ((p4 & 1) == 0) {
									boolean v24 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
									if (v24 != 0) {
										if (p2 != -9999) {
											long v25 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
											IGateKeeperService v26 = LockSettingsService.getGateKeeperService();
											SyntheticPasswordManager$AuthenticationResult v27 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v26, v25, p1, p2, p3);
											int v28 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
											if (v28 != 0) {
												byte[] v29 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
												this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v29);
												IGateKeeperService v31 = LockSettingsService.getGateKeeperService();
												VerifyCredentialResponse v32 = this.mSpManager.verifyChallenge(v31, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
												int v33 = v32.getResponseCode();
												if (v33 == 0) {
													VerifyCredentialResponse v14 = VerifyCredentialResponse.ERROR;
													if (v14 == 0) {
														if (UserInfo.id != -9999) {
															LockSettingsStorage$CredentialHash v36 = LockSettingsStorage.readPasswordHashIfExists(p2);
															if (v36 == 0) {
																LockSettingsStorage$CredentialHash v37 = LockSettingsStorage.readPatternHashIfExists(p2);
																if (v37 == 0) {
																	LockSettingsStorage$CredentialHash v38 = LockSettingsStorage$CredentialHash.createEmptyHash();
																	LockSettingsStorage$CredentialHash v35 = v38;
																	if (LockSettingsStorage$CredentialHash.type != 2) {
																		int v40 = LockscreenCredential.getType();
																		if (v40 == 4) {
																			int v41 = LockscreenCredential.getType();
																			if (v41 != 3) {
																				boolean v39 = ;
																				if (v39 != 0) {
																					if (v35 == 0) {
																						if (LockSettingsStorage$CredentialHash.hash.length != 0) {
																							boolean v43 = p1.isNone();
																							if (v43 == 0) {
																								if (v35 == 0) {
																									if (LockSettingsStorage$CredentialHash.hash.length == 0) {
																										boolean v44 = p1.isNone();
																										if (v44 == 0) {
																											StrictMode.noteDiskRead();
																											IGateKeeperService v46 = LockSettingsService.getGateKeeperService();
																											byte[] v47 = p1.getCredential();
																											GateKeeperResponse v48 = v46.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v47);
																											VerifyCredentialResponse v49 = LockSettingsService.convertResponse();
																											boolean v50 = .getShouldReEnroll();
																											int v51 = v49.getResponseCode();
																											if (v51 != 0) {
																												if (p3 == 0) {
																													p3.onCredentialVerified();
																													LockSettingsService.setUserPasswordMetrics(p1, p2);
																													byte[] v55 = p1.getCredential();
																													LockSettingsService.unlockKeystore(v55, p2);
																													byte[] v63 = LockSettingsService.secretFromCredential(p1);
																													LockSettingsService.unlockUser(p2, v63);
																													boolean v65 = LockSettingsService.isProfileWithSeparatedLock(p2);
																													if (v65 == 0) {
																														LockSettingsService.setDeviceUnlockedForUser(p2);
																														if (v50 == 0) {
																															boolean v67 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
																															LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
																															VerifyCredentialResponse v42 = v49;
																															int v69 = this.mResponseCode;
																															if (v69 != 0) {
																																Message v71 = this.mHandler.obtainMessage(5, p2, 0);
																																v71.sendToTarget();
																																VerifyCredentialResponse v9 = v42;
																																int v73 = v9.getResponseCode();
																																if (v73 == 0) {
																																	String v76 = LockSettingsStorage.getChildProfileLockFile(p1);
																																	byte[] v77 = LockSettingsStorage.readFile(v76);
																																	byte[] v75 = v77;
																																	if (v75 == 0) {
																																		byte[] v78 = Arrays.copyOfRange(v75, 0, 12);
																																		byte[] v79 = Arrays.copyOfRange(v75, 12, v75.length);
																																		StringBuilder v80 = new StringBuilder();
																																		StringBuilder v82 = v80.append("profile_key_name_decrypt_");
																																		StringBuilder v83 = v80.append(p2);
																																		String v84 = v80.toString();
																																		Key v85 = this.mJavaKeyStore.getKey(v84, 0);
																																		Cipher v86 = Cipher.getInstance("AES/GCM/NoPadding");
																																		GCMParameterSpec v87 = new GCMParameterSpec(128,v78);
																																		v86.init(2, v85, v87);
																																		byte[] v90 = v86.doFinal(v79);
																																		LockscreenCredential v92 = new LockscreenCredential(4,v93);
																																		byte[] v93 = Arrays.copyOf(v90, v90.length);
																																		LockscreenCredential v91 = v92;
																																		Arrays.fill(v90, 0);
																																		boolean v97 = this.mEncryptedPasswords.contains(p1);
																																		if (v97 == 0) {
																																			UserInfo v98 = this.mUserManager.getProfileParent(p1);
																																			if (v98 == 0) {
																																				if (UserInfo.id == 0) {
																																					String v99 = ManagedProfilePasswordCache.getEncryptionKeyName(p1);
																																					Provider v100 = this.mKeyStore.getProvider();
																																					KeyGenerator v101 = KeyGenerator.getInstance("AES", v100);
																																					KeyGenParameterSpec$Builder v102 = new KeyGenParameterSpec$Builder(v99,3);
																																					KeyGenParameterSpec$Builder v104 = v102.setKeySize(256);
																																					String v105 = new String(1);
																																					KeyGenParameterSpec$Builder v106 = v104.setBlockModes(v105);
																																					int v107 = SyntheticPasswordCrypto.keyNamespace();
																																					KeyGenParameterSpec$Builder v108 = v106.setNamespace(v107);
																																					String v109 = new String(1);
																																					KeyGenParameterSpec$Builder v110 = v108.setEncryptionPaddings(v109);
																																					KeyGenParameterSpec$Builder v111 = v110.setUserAuthenticationRequired(1);
																																					KeyGenParameterSpec$Builder v112 = v111.setUserAuthenticationValidityDurationSeconds(this.CACHE_TIMEOUT_SECONDS);
																																					KeyGenParameterSpec v113 = v112.build();
																																					v101.init(v113);
																																					SecretKey v115 = v101.generateKey();
																																					Cipher v116 = Cipher.getInstance("AES/GCM/NoPadding");
																																					v116.init(1, v115);
																																					byte[] v118 = v91.getCredential();
																																					byte[] v119 = v116.doFinal(v118);
																																					byte[] v120 = v116.getIV();
																																					LockscreenCredential v74 = v91;
																																					if (v74 == 0) {
																																						boolean v123 = v74.isNone();
																																						if (v123 != 0) {
																																							if (p2 != -9999) {
																																								ContentResolver v124 = this.mContext.getContentResolver();
																																								int v126 = Settings$Global.getInt(v124, "device_provisioned", 0);
																																								int v125 = v126;
																																								if (v125 == 0) {
																																									boolean v128 = this.mInjector.hasEnrolledBiometrics(p2);
																																									if ((p4 & 1) == 0) {
																																										boolean v137 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
																																										if (v137 != 0) {
																																											if (p2 != -9999) {
																																												long v138 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
																																												IGateKeeperService v139 = LockSettingsService.getGateKeeperService();
																																												SyntheticPasswordManager$AuthenticationResult v140 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v139, v138, p1, p2, p3);
																																												int v141 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
																																												if (v141 != 0) {
																																													byte[] v142 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
																																													this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v142);
																																													IGateKeeperService v144 = LockSettingsService.getGateKeeperService();
																																													VerifyCredentialResponse v145 = this.mSpManager.verifyChallenge(v144, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
																																													int v146 = v145.getResponseCode();
																																													if (v146 == 0) {
																																														VerifyCredentialResponse v127 = VerifyCredentialResponse.ERROR;
																																														if (v127 == 0) {
																																															if (p2 != -9999) {
																																																LockSettingsStorage$CredentialHash v149 = LockSettingsStorage.readPasswordHashIfExists(p2);
																																																if (v149 == 0) {
																																																	LockSettingsStorage$CredentialHash v150 = LockSettingsStorage.readPatternHashIfExists(p2);
																																																	if (v150 == 0) {
																																																		LockSettingsStorage$CredentialHash v151 = LockSettingsStorage$CredentialHash.createEmptyHash();
																																																		LockSettingsStorage$CredentialHash v148 = v151;
																																																		if (LockSettingsStorage$CredentialHash.type != 2) {
																																																			int v153 = LockscreenCredential.getType();
																																																			if (v153 == 4) {
																																																				int v154 = LockscreenCredential.getType();
																																																				if (v154 != 3) {
																																																					boolean v152 = ;
																																																					if (v152 != 0) {
																																																						if (v148 == 0) {
																																																							if (LockSettingsStorage$CredentialHash.hash.length != 0) {
																																																								boolean v156 = p1.isNone();
																																																								if (v156 == 0) {
																																																									if (v148 == 0) {
																																																										if (LockSettingsStorage$CredentialHash.hash.length == 0) {
																																																											boolean v157 = p1.isNone();
																																																											if (v157 == 0) {
																																																												StrictMode.noteDiskRead();
																																																												IGateKeeperService v159 = LockSettingsService.getGateKeeperService();
																																																												byte[] v160 = p1.getCredential();
																																																												GateKeeperResponse v161 = v159.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v160);
																																																												VerifyCredentialResponse v162 = LockSettingsService.convertResponse();
																																																												boolean v163 = .getShouldReEnroll();
																																																												int v164 = v162.getResponseCode();
																																																												if (v164 != 0) {
																																																													if (p3 == 0) {
																																																														p3.onCredentialVerified();
																																																														LockSettingsService.setUserPasswordMetrics(p1, p2);
																																																														byte[] v168 = p1.getCredential();
																																																														LockSettingsService.unlockKeystore(v168, p2);
																																																														byte[] v176 = LockSettingsService.secretFromCredential(p1);
																																																														LockSettingsService.unlockUser(p2, v176);
																																																														boolean v178 = LockSettingsService.isProfileWithSeparatedLock(p2);
																																																														if (v178 == 0) {
																																																															LockSettingsService.setDeviceUnlockedForUser(p2);
																																																															if (v163 == 0) {
																																																																boolean v180 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
																																																																LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
																																																																VerifyCredentialResponse v155 = v162;
																																																																int v182 = this.mResponseCode;
																																																																if (v182 != 0) {
																																																																	Message v184 = this.mHandler.obtainMessage(5, p2, 0);
																																																																	v184.sendToTarget();
																																																																	VerifyCredentialResponse v122 = v155;
																																																																	p0.scheduleGc();
																																																																	return v122;
																																																																}
																																																															}
																																																														}
																																																													}
																																																												}
																																																											}
																																																										}
																																																									}
																																																								}
																																																							}
																																																						}
																																																					}
																																																				}
																																																			}
																																																		}
																																																	}
																																																}
																																															}
																																														}
																																													}
																																												}
																																											}
																																										}
																																									}
																																								}
																																							}
																																						}
																																					}
																																				}
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

This is path 2 for the API with depth 2:
public VerifyCredentialResponse verifyTiedProfileChallenge(LockscreenCredential p1, int p2, int p3){
	UserManager v4 = LockSettingsService.getUserManagerFromCache(p1);
	boolean v5 = v4.isCredentialSharableWithParent();
	boolean v3 = v5;
	if (v3 == 0) {
		boolean v7 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
		boolean v6 = v7;
		if (v6 != 0) {
			boolean v2 = ;
			if (v2 == 0) {
				UserInfo v8 = this.mUserManager.getProfileParent(p2);
				if (p1 == 0) {
					boolean v10 = p1.isNone();
					if (v10 != 0) {
						if (UserInfo.id != -9999) {
							ContentResolver v11 = this.mContext.getContentResolver();
							int v13 = Settings$Global.getInt(v11, "device_provisioned", 0);
							int v12 = v13;
							if (v12 == 0) {
								boolean v15 = this.mInjector.hasEnrolledBiometrics(p2);
								if ((p4 & 1) == 0) {
									boolean v24 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
									if (v24 != 0) {
										if (p2 != -9999) {
											long v25 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
											IGateKeeperService v26 = LockSettingsService.getGateKeeperService();
											SyntheticPasswordManager$AuthenticationResult v27 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v26, v25, p1, p2, p3);
											int v28 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
											if (v28 != 0) {
												byte[] v29 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
												this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v29);
												IGateKeeperService v31 = LockSettingsService.getGateKeeperService();
												VerifyCredentialResponse v32 = this.mSpManager.verifyChallenge(v31, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
												int v33 = v32.getResponseCode();
												if (v33 == 0) {
													VerifyCredentialResponse v14 = VerifyCredentialResponse.ERROR;
													if (v14 == 0) {
														if (UserInfo.id != -9999) {
															LockSettingsStorage$CredentialHash v36 = LockSettingsStorage.readPasswordHashIfExists(p2);
															if (v36 == 0) {
																LockSettingsStorage$CredentialHash v37 = LockSettingsStorage.readPatternHashIfExists(p2);
																if (v37 == 0) {
																	LockSettingsStorage$CredentialHash v38 = LockSettingsStorage$CredentialHash.createEmptyHash();
																	LockSettingsStorage$CredentialHash v35 = v38;
																	if (LockSettingsStorage$CredentialHash.type != 2) {
																		int v40 = LockscreenCredential.getType();
																		if (v40 == 4) {
																			int v41 = LockscreenCredential.getType();
																			if (v41 != 3) {
																				boolean v39 = ;
																				if (v39 != 0) {
																					if (v35 == 0) {
																						if (LockSettingsStorage$CredentialHash.hash.length != 0) {
																							boolean v43 = p1.isNone();
																							if (v43 == 0) {
																								if (v35 == 0) {
																									if (LockSettingsStorage$CredentialHash.hash.length == 0) {
																										boolean v44 = p1.isNone();
																										if (v44 == 0) {
																											StrictMode.noteDiskRead();
																											IGateKeeperService v46 = LockSettingsService.getGateKeeperService();
																											byte[] v47 = p1.getCredential();
																											GateKeeperResponse v48 = v46.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v47);
																											VerifyCredentialResponse v49 = LockSettingsService.convertResponse();
																											boolean v50 = .getShouldReEnroll();
																											int v51 = v49.getResponseCode();
																											if (v51 != 0) {
																												if (p3 == 0) {
																													p3.onCredentialVerified();
																													LockSettingsService.setUserPasswordMetrics(p1, p2);
																													byte[] v55 = p1.getCredential();
																													LockSettingsService.unlockKeystore(v55, p2);
																													byte[] v63 = LockSettingsService.secretFromCredential(p1);
																													LockSettingsService.unlockUser(p2, v63);
																													boolean v65 = LockSettingsService.isProfileWithSeparatedLock(p2);
																													if (v65 == 0) {
																														LockSettingsService.setDeviceUnlockedForUser(p2);
																														if (v50 == 0) {
																															boolean v67 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
																															LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
																															VerifyCredentialResponse v42 = v49;
																															int v69 = this.mResponseCode;
																															if (v69 != 0) {
																																Message v71 = this.mHandler.obtainMessage(5, p2, 0);
																																v71.sendToTarget();
																																VerifyCredentialResponse v9 = v42;
																																int v73 = v9.getResponseCode();
																																if (v73 == 0) {
																																	String v76 = LockSettingsStorage.getChildProfileLockFile(p1);
																																	byte[] v77 = LockSettingsStorage.readFile(v76);
																																	byte[] v75 = v77;
																																	if (v75 == 0) {
																																		byte[] v78 = Arrays.copyOfRange(v75, 0, 12);
																																		byte[] v79 = Arrays.copyOfRange(v75, 12, v75.length);
																																		StringBuilder v80 = new StringBuilder();
																																		StringBuilder v82 = v80.append("profile_key_name_decrypt_");
																																		StringBuilder v83 = v80.append(p2);
																																		String v84 = v80.toString();
																																		Key v85 = this.mJavaKeyStore.getKey(v84, 0);
																																		Cipher v86 = Cipher.getInstance("AES/GCM/NoPadding");
																																		GCMParameterSpec v87 = new GCMParameterSpec(128,v78);
																																		v86.init(2, v85, v87);
																																		byte[] v90 = v86.doFinal(v79);
																																		LockscreenCredential v92 = new LockscreenCredential(4,v93);
																																		byte[] v93 = Arrays.copyOf(v90, v90.length);
																																		LockscreenCredential v91 = v92;
																																		Arrays.fill(v90, 0);
																																		boolean v97 = this.mEncryptedPasswords.contains(p1);
																																		if (v97 == 0) {
																																			UserInfo v98 = this.mUserManager.getProfileParent(p1);
																																			if (v98 == 0) {
																																				if (UserInfo.id == 0) {
																																					String v99 = ManagedProfilePasswordCache.getEncryptionKeyName(p1);
																																					Provider v100 = this.mKeyStore.getProvider();
																																					KeyGenerator v101 = KeyGenerator.getInstance("AES", v100);
																																					KeyGenParameterSpec$Builder v102 = new KeyGenParameterSpec$Builder(v99,3);
																																					KeyGenParameterSpec$Builder v104 = v102.setKeySize(256);
																																					String v105 = new String(1);
																																					KeyGenParameterSpec$Builder v106 = v104.setBlockModes(v105);
																																					int v107 = SyntheticPasswordCrypto.keyNamespace();
																																					KeyGenParameterSpec$Builder v108 = v106.setNamespace(v107);
																																					String v109 = new String(1);
																																					KeyGenParameterSpec$Builder v110 = v108.setEncryptionPaddings(v109);
																																					KeyGenParameterSpec$Builder v111 = v110.setUserAuthenticationRequired(1);
																																					KeyGenParameterSpec$Builder v112 = v111.setUserAuthenticationValidityDurationSeconds(this.CACHE_TIMEOUT_SECONDS);
																																					KeyGenParameterSpec v113 = v112.build();
																																					v101.init(v113);
																																					SecretKey v115 = v101.generateKey();
																																					Cipher v116 = Cipher.getInstance("AES/GCM/NoPadding");
																																					v116.init(1, v115);
																																					byte[] v118 = v91.getCredential();
																																					byte[] v119 = v116.doFinal(v118);
																																					byte[] v120 = v116.getIV();
																																					LockscreenCredential v74 = v91;
																																					if (v74 == 0) {
																																						boolean v123 = v74.isNone();
																																						if (v123 != 0) {
																																							if (p2 != -9999) {
																																								ContentResolver v124 = this.mContext.getContentResolver();
																																								int v126 = Settings$Global.getInt(v124, "device_provisioned", 0);
																																								int v125 = v126;
																																								if (v125 == 0) {
																																									boolean v128 = this.mInjector.hasEnrolledBiometrics(p2);
																																									if ((p4 & 1) == 0) {
																																										boolean v137 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
																																										if (v137 != 0) {
																																											if (p2 != -9999) {
																																												long v138 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
																																												IGateKeeperService v139 = LockSettingsService.getGateKeeperService();
																																												SyntheticPasswordManager$AuthenticationResult v140 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v139, v138, p1, p2, p3);
																																												int v141 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
																																												if (v141 != 0) {
																																													byte[] v142 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
																																													this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v142);
																																													IGateKeeperService v144 = LockSettingsService.getGateKeeperService();
																																													VerifyCredentialResponse v145 = this.mSpManager.verifyChallenge(v144, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
																																													int v146 = v145.getResponseCode();
																																													if (v146 == 0) {
																																														VerifyCredentialResponse v127 = VerifyCredentialResponse.ERROR;
																																														if (v127 == 0) {
																																															if (p2 != -9999) {
																																																LockSettingsStorage$CredentialHash v149 = LockSettingsStorage.readPasswordHashIfExists(p2);
																																																if (v149 == 0) {
																																																	LockSettingsStorage$CredentialHash v150 = LockSettingsStorage.readPatternHashIfExists(p2);
																																																	if (v150 == 0) {
																																																		LockSettingsStorage$CredentialHash v151 = LockSettingsStorage$CredentialHash.createEmptyHash();
																																																		LockSettingsStorage$CredentialHash v148 = v151;
																																																		if (LockSettingsStorage$CredentialHash.type != 2) {
																																																			int v153 = LockscreenCredential.getType();
																																																			if (v153 == 4) {
																																																				int v154 = LockscreenCredential.getType();
																																																				if (v154 != 3) {
																																																					boolean v152 = ;
																																																					if (v152 != 0) {
																																																						if (v148 == 0) {
																																																							if (LockSettingsStorage$CredentialHash.hash.length != 0) {
																																																								boolean v156 = p1.isNone();
																																																								if (v156 == 0) {
																																																									if (v148 == 0) {
																																																										if (LockSettingsStorage$CredentialHash.hash.length == 0) {
																																																											boolean v157 = p1.isNone();
																																																											if (v157 == 0) {
																																																												StrictMode.noteDiskRead();
																																																												IGateKeeperService v159 = LockSettingsService.getGateKeeperService();
																																																												byte[] v160 = p1.getCredential();
																																																												GateKeeperResponse v161 = v159.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v160);
																																																												VerifyCredentialResponse v162 = LockSettingsService.convertResponse();
																																																												boolean v163 = .getShouldReEnroll();
																																																												int v164 = v162.getResponseCode();
																																																												if (v164 != 0) {
																																																													if (p3 == 0) {
																																																														p3.onCredentialVerified();
																																																														LockSettingsService.setUserPasswordMetrics(p1, p2);
																																																														byte[] v168 = p1.getCredential();
																																																														LockSettingsService.unlockKeystore(v168, p2);
																																																														byte[] v176 = LockSettingsService.secretFromCredential(p1);
																																																														LockSettingsService.unlockUser(p2, v176);
																																																														boolean v178 = LockSettingsService.isProfileWithSeparatedLock(p2);
																																																														if (v178 == 0) {
																																																															LockSettingsService.setDeviceUnlockedForUser(p2);
																																																															if (v163 == 0) {
																																																																boolean v180 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
																																																																LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
																																																																VerifyCredentialResponse v155 = v162;
																																																																int v182 = this.mResponseCode;
																																																																if (v182 != 0) {
																																																																	Message v184 = this.mHandler.obtainMessage(5, p2, 0);
																																																																	v184.sendToTarget();
																																																																	VerifyCredentialResponse v122 = v155;
																																																																	p0.scheduleGc();
																																																																	return v122;
																																																																}
																																																															}
																																																														}
																																																													}
																																																												}
																																																											}
																																																										}
																																																									}
																																																								}
																																																							}
																																																						}
																																																					}
																																																				}
																																																			}
																																																		}
																																																	}
																																																}
																																															}
																																														}
																																													}
																																												}
																																											}
																																										}
																																									}
																																								}
																																							}
																																						}
																																					}
																																				}
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

This is path 3 for the API with depth 2:
public VerifyCredentialResponse verifyTiedProfileChallenge(LockscreenCredential p1, int p2, int p3){
	UserManager v4 = LockSettingsService.getUserManagerFromCache(p1);
	boolean v5 = v4.isCredentialSharableWithParent();
	boolean v3 = v5;
	if (v3 == 0) {
		boolean v7 = this.mStorage.getBoolean("lockscreen.profilechallenge", 0, p1);
		boolean v6 = v7;
		if (v6 != 0) {
			boolean v2 = ;
			if (v2 == 0) {
				UserInfo v8 = this.mUserManager.getProfileParent(p2);
				if (p1 == 0) {
					boolean v10 = p1.isNone();
					if (v10 != 0) {
						if (UserInfo.id != -9999) {
							ContentResolver v11 = this.mContext.getContentResolver();
							int v13 = Settings$Global.getInt(v11, "device_provisioned", 0);
							int v12 = v13;
							if (v12 == 0) {
								boolean v15 = this.mInjector.hasEnrolledBiometrics(p2);
								if ((p4 & 1) == 0) {
									boolean v24 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
									if (v24 != 0) {
										if (p2 != -9999) {
											long v25 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
											IGateKeeperService v26 = LockSettingsService.getGateKeeperService();
											SyntheticPasswordManager$AuthenticationResult v27 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v26, v25, p1, p2, p3);
											int v28 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
											if (v28 != 0) {
												byte[] v29 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
												this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v29);
												IGateKeeperService v31 = LockSettingsService.getGateKeeperService();
												VerifyCredentialResponse v32 = this.mSpManager.verifyChallenge(v31, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
												int v33 = v32.getResponseCode();
												if (v33 == 0) {
													VerifyCredentialResponse v14 = VerifyCredentialResponse.ERROR;
													if (v14 == 0) {
														if (UserInfo.id != -9999) {
															LockSettingsStorage$CredentialHash v36 = LockSettingsStorage.readPasswordHashIfExists(p2);
															if (v36 == 0) {
																LockSettingsStorage$CredentialHash v37 = LockSettingsStorage.readPatternHashIfExists(p2);
																if (v37 == 0) {
																	LockSettingsStorage$CredentialHash v35 = v37;
																	if (LockSettingsStorage$CredentialHash.type != 2) {
																		int v39 = LockscreenCredential.getType();
																		if (v39 == 4) {
																			int v40 = LockscreenCredential.getType();
																			if (v40 != 3) {
																				boolean v38 = ;
																				if (v38 != 0) {
																					if (v35 == 0) {
																						if (LockSettingsStorage$CredentialHash.hash.length != 0) {
																							boolean v42 = p1.isNone();
																							if (v42 == 0) {
																								if (v35 == 0) {
																									if (LockSettingsStorage$CredentialHash.hash.length == 0) {
																										boolean v43 = p1.isNone();
																										if (v43 == 0) {
																											StrictMode.noteDiskRead();
																											IGateKeeperService v45 = LockSettingsService.getGateKeeperService();
																											byte[] v46 = p1.getCredential();
																											GateKeeperResponse v47 = v45.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v46);
																											VerifyCredentialResponse v48 = LockSettingsService.convertResponse();
																											boolean v49 = .getShouldReEnroll();
																											int v50 = v48.getResponseCode();
																											if (v50 != 0) {
																												if (p3 == 0) {
																													p3.onCredentialVerified();
																													LockSettingsService.setUserPasswordMetrics(p1, p2);
																													byte[] v54 = p1.getCredential();
																													LockSettingsService.unlockKeystore(v54, p2);
																													byte[] v62 = LockSettingsService.secretFromCredential(p1);
																													LockSettingsService.unlockUser(p2, v62);
																													boolean v64 = LockSettingsService.isProfileWithSeparatedLock(p2);
																													if (v64 == 0) {
																														LockSettingsService.setDeviceUnlockedForUser(p2);
																														if (v49 == 0) {
																															boolean v66 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
																															LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
																															VerifyCredentialResponse v41 = v48;
																															int v68 = this.mResponseCode;
																															if (v68 != 0) {
																																Message v70 = this.mHandler.obtainMessage(5, p2, 0);
																																v70.sendToTarget();
																																VerifyCredentialResponse v9 = v41;
																																int v72 = v9.getResponseCode();
																																if (v72 == 0) {
																																	String v75 = LockSettingsStorage.getChildProfileLockFile(p1);
																																	byte[] v76 = LockSettingsStorage.readFile(v75);
																																	byte[] v74 = v76;
																																	if (v74 == 0) {
																																		byte[] v77 = Arrays.copyOfRange(v74, 0, 12);
																																		byte[] v78 = Arrays.copyOfRange(v74, 12, v74.length);
																																		StringBuilder v79 = new StringBuilder();
																																		StringBuilder v81 = v79.append("profile_key_name_decrypt_");
																																		StringBuilder v82 = v79.append(p2);
																																		String v83 = v79.toString();
																																		Key v84 = this.mJavaKeyStore.getKey(v83, 0);
																																		Cipher v85 = Cipher.getInstance("AES/GCM/NoPadding");
																																		GCMParameterSpec v86 = new GCMParameterSpec(128,v77);
																																		v85.init(2, v84, v86);
																																		byte[] v89 = v85.doFinal(v78);
																																		LockscreenCredential v91 = new LockscreenCredential(4,v92);
																																		byte[] v92 = Arrays.copyOf(v89, v89.length);
																																		LockscreenCredential v90 = v91;
																																		Arrays.fill(v89, 0);
																																		boolean v96 = this.mEncryptedPasswords.contains(p1);
																																		if (v96 == 0) {
																																			UserInfo v97 = this.mUserManager.getProfileParent(p1);
																																			if (v97 == 0) {
																																				if (UserInfo.id == 0) {
																																					String v98 = ManagedProfilePasswordCache.getEncryptionKeyName(p1);
																																					Provider v99 = this.mKeyStore.getProvider();
																																					KeyGenerator v100 = KeyGenerator.getInstance("AES", v99);
																																					KeyGenParameterSpec$Builder v101 = new KeyGenParameterSpec$Builder(v98,3);
																																					KeyGenParameterSpec$Builder v103 = v101.setKeySize(256);
																																					String v104 = new String(1);
																																					KeyGenParameterSpec$Builder v105 = v103.setBlockModes(v104);
																																					int v106 = SyntheticPasswordCrypto.keyNamespace();
																																					KeyGenParameterSpec$Builder v107 = v105.setNamespace(v106);
																																					String v108 = new String(1);
																																					KeyGenParameterSpec$Builder v109 = v107.setEncryptionPaddings(v108);
																																					KeyGenParameterSpec$Builder v110 = v109.setUserAuthenticationRequired(1);
																																					KeyGenParameterSpec$Builder v111 = v110.setUserAuthenticationValidityDurationSeconds(this.CACHE_TIMEOUT_SECONDS);
																																					KeyGenParameterSpec v112 = v111.build();
																																					v100.init(v112);
																																					SecretKey v114 = v100.generateKey();
																																					Cipher v115 = Cipher.getInstance("AES/GCM/NoPadding");
																																					v115.init(1, v114);
																																					byte[] v117 = v90.getCredential();
																																					byte[] v118 = v115.doFinal(v117);
																																					byte[] v119 = v115.getIV();
																																					LockscreenCredential v73 = v90;
																																					if (v73 == 0) {
																																						boolean v122 = v73.isNone();
																																						if (v122 != 0) {
																																							if (p2 != -9999) {
																																								ContentResolver v123 = this.mContext.getContentResolver();
																																								int v125 = Settings$Global.getInt(v123, "device_provisioned", 0);
																																								int v124 = v125;
																																								if (v124 == 0) {
																																									boolean v127 = this.mInjector.hasEnrolledBiometrics(p2);
																																									if ((p4 & 1) == 0) {
																																										boolean v136 = LockSettingsService.isSyntheticPasswordBasedCredentialLocked(p2);
																																										if (v136 != 0) {
																																											if (p2 != -9999) {
																																												long v137 = LockSettingsService.getSyntheticPasswordHandleLocked(p2);
																																												IGateKeeperService v138 = LockSettingsService.getGateKeeperService();
																																												SyntheticPasswordManager$AuthenticationResult v139 = this.mSpManager.unwrapPasswordBasedSyntheticPassword(v138, v137, p1, p2, p3);
																																												int v140 = SyntheticPasswordManager$AuthenticationResult.gkResponse.getResponseCode();
																																												if (v140 != 0) {
																																													byte[] v141 = SyntheticPasswordManager$AuthenticationResult.authToken.deriveGkPassword();
																																													this.mBiometricDeferredQueue.addPendingLockoutResetForUser(p2, v141);
																																													IGateKeeperService v143 = LockSettingsService.getGateKeeperService();
																																													VerifyCredentialResponse v144 = this.mSpManager.verifyChallenge(v143, SyntheticPasswordManager$AuthenticationResult.authToken, 0, p2);
																																													int v145 = v144.getResponseCode();
																																													if (v145 == 0) {
																																														VerifyCredentialResponse v126 = VerifyCredentialResponse.ERROR;
																																														if (v126 == 0) {
																																															if (p2 != -9999) {
																																																LockSettingsStorage$CredentialHash v148 = LockSettingsStorage.readPasswordHashIfExists(p2);
																																																if (v148 == 0) {
																																																	LockSettingsStorage$CredentialHash v149 = LockSettingsStorage.readPatternHashIfExists(p2);
																																																	if (v149 == 0) {
																																																		LockSettingsStorage$CredentialHash v150 = LockSettingsStorage$CredentialHash.createEmptyHash();
																																																		LockSettingsStorage$CredentialHash v147 = v150;
																																																		if (LockSettingsStorage$CredentialHash.type != 2) {
																																																			int v152 = LockscreenCredential.getType();
																																																			if (v152 == 4) {
																																																				int v153 = LockscreenCredential.getType();
																																																				if (v153 != 3) {
																																																					boolean v151 = ;
																																																					if (v151 != 0) {
																																																						if (v147 == 0) {
																																																							if (LockSettingsStorage$CredentialHash.hash.length != 0) {
																																																								boolean v155 = p1.isNone();
																																																								if (v155 == 0) {
																																																									if (v147 == 0) {
																																																										if (LockSettingsStorage$CredentialHash.hash.length == 0) {
																																																											boolean v156 = p1.isNone();
																																																											if (v156 == 0) {
																																																												StrictMode.noteDiskRead();
																																																												IGateKeeperService v158 = LockSettingsService.getGateKeeperService();
																																																												byte[] v159 = p1.getCredential();
																																																												GateKeeperResponse v160 = v158.verifyChallenge(p2, 0, LockSettingsStorage$CredentialHash.hash, v159);
																																																												VerifyCredentialResponse v161 = LockSettingsService.convertResponse();
																																																												boolean v162 = .getShouldReEnroll();
																																																												int v163 = v161.getResponseCode();
																																																												if (v163 != 0) {
																																																													if (p3 == 0) {
																																																														p3.onCredentialVerified();
																																																														LockSettingsService.setUserPasswordMetrics(p1, p2);
																																																														byte[] v167 = p1.getCredential();
																																																														LockSettingsService.unlockKeystore(v167, p2);
																																																														byte[] v175 = LockSettingsService.secretFromCredential(p1);
																																																														LockSettingsService.unlockUser(p2, v175);
																																																														boolean v177 = LockSettingsService.isProfileWithSeparatedLock(p2);
																																																														if (v177 == 0) {
																																																															LockSettingsService.setDeviceUnlockedForUser(p2);
																																																															if (v162 == 0) {
																																																																boolean v179 = LockSettingsService.setLockCredentialInternal(p1, p1, p2, 0);
																																																																LockSettingsService.sendCredentialsOnUnlockIfRequired(p1, p2);
																																																																VerifyCredentialResponse v154 = v161;
																																																																int v181 = this.mResponseCode;
																																																																if (v181 != 0) {
																																																																	Message v183 = this.mHandler.obtainMessage(5, p2, 0);
																																																																	v183.sendToTarget();
																																																																	VerifyCredentialResponse v121 = v154;
																																																																	p0.scheduleGc();
																																																																	return v121;
																																																																}
																																																															}
																																																														}
																																																													}
																																																												}
																																																											}
																																																										}
																																																									}
																																																								}
																																																							}
																																																						}
																																																					}
																																																				}
																																																			}
																																																		}
																																																	}
																																																}
																																															}
																																														}
																																													}
																																												}
																																											}
																																										}
																																									}
																																								}
																																							}
																																						}
																																					}
																																				}
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
